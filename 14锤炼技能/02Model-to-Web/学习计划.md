下面是一份**以产出为导向**、直接贴合刚拿到的“Model-to-Web 模板仓库”的**12 周学习路线**。目标是：

1. 能熟练用 **TypeScript + Next.js** 把任何模型做成专业网页；
2. 能用 **Go** 写高性能的数据/服务组件，与现有 Python 服务协同。

每周都有**明确产出物**、**关键知识点**、**练习任务**与**验收标准**。按周推进就能稳步升级；若你有更多时间，可把每周拉成 5–7 天节奏。

---

## 总览（12 周里程碑）

* **第 1–4 周（TS/Next.js 基础 → 强化）**：把前端页面从“能用”升级到“专业可用”（类型安全、组件化、表单、可视化、错误处理、部署）。
* **第 5–8 周（Go 基础 → 并发/工程化）**：写出稳定、可测试、带并发的数据/服务组件，跑在 Docker 里。
* **第 9–12 周（整合与进阶）**：TS+Go+Python 三栈整合：网关/监控/鉴权/批处理；完成一个可展示的**作品级 Demo**。

---

## 第 1–4 周：TypeScript + Next.js（从 0 到产线可用）

### 第 1 周：TypeScript 核心语法上手（结合你的前端目录）

**要学的点**

* 基础类型、联合/交叉、类型别名 vs 接口、字面量类型
* 函数类型、可选与默认、**类型收窄（narrowing）**
* 泛型（数组、函数）、`unknown` vs `any`
* `enum`/`as const`、`keyof`、索引类型
* `Promise<T>` 与 `async/await` 的类型

**把这些用到模板里**

* 在 `frontend/lib/api.ts` 中给 `predictJson`、`predictCsv` 增加**精确返回类型**：`PredictResponse`（与后端 OpenAPI 一致：`y_pred: number[]; y_proba?: number[][]; target_names?: string[]`）。
* 在 `app/page.tsx` 中为所有状态变量加类型，并通过类型收窄处理错误分支。

**产出物（验收）**

* `types.ts`：定义 `PredictRequest`/`PredictResponse` 类型，并被 `api.ts`、`page.tsx` 引用。
* 任何 `any` 都有解释理由（最好 0 个）。

---

### 第 2 周：Next.js App Router & 表单/状态/错误治理

**要学的点**

* Next App Router 基本约定（`app/` 目录）
* 受控组件、表单处理、文件上传
* 错误边界（`error.tsx`）、加载状态（`loading.tsx`）、Suspense 基础
* 环境变量（`NEXT_PUBLIC_*`）与跨域

**在模板里做**

* 把 JSON/CVS 两个入口拆成**可复用组件**（如 `components/JsonPanel.tsx`、`components/CsvPanel.tsx`）。
* 为 CSV 上传加**进度条**与**错误提示**（基于 Axios `onUploadProgress`）。
* 新增 `error.tsx` & `loading.tsx`。

**产出物（验收）**

* 组件化后页面更清晰，切换 JSON/CSV 流畅。
* 错误在 UI 可见且可读，不抛生涩报错。

---

### 第 3 周：类型安全的 API 合同 & 可视化

**要学的点**

* 用 **OpenAPI JSON** 生成 TS 类型（了解 `openapi-typescript` 的思路），或手写同步类型
* 基本可视化：选择 **Plotly** 或 ECharts 的 TS 用法
* 数据映射 → 前端图表（例如显示 `y_pred` 的类别分布、`y_proba` 条形图）

**在模板里做**

* 新建 `components/ProbaChart.tsx`：若后端有 `y_proba`，对每个样本画条形或雷达图。
* 新建 `components/PredTable.tsx`：表格显示输入与预测结果（带分页或折叠）。

**产出物（验收）**

* 页面可视化清晰展示 `y_pred`/`y_proba`。
* TS 类型与后端返回结构**完全一致**，不再用 `any` 兜底。

---

### 第 4 周：生产要素（鉴权雏形、配置、部署）

**要学的点**

* 最小鉴权：前端存 Token、请求拦截器（Axios）
* 环境区分：本地/预发/生产的 API BASE 管理
* Docker 化前端、Nginx 静态托管或 Vercel 部署的要点

**在模板里做**

* 新建 `lib/http.ts`：统一创建 axios 实例（含 `Authorization` 头），集中错误拦截。
* 支持 `NEXT_PUBLIC_API_BASE` 三套环境变量；写 `env.example`。
* **可选**：给页面加简单登录占位（假 token），演示受限入口。

**产出物（验收）**

* `docker build` 前端镜像可起，或一键部署到 Vercel（如选这条路）。
* README 补充“如何配环境变量/部署”。

---

## 第 5–8 周：Go（面向数据/服务的工程化与并发）

### 第 5 周：Go 语言核心（语法 + 工具链）

**要学的点**

* 值/指针、切片/映射、方法与接口、接收者语义
* 错误处理风格、`defer`、包结构
* `go mod`、`go test`、`go vet`、`golangci-lint`

**练习**

* 写 `pkg/csvutil`：读取 CSV → 校验列名 → 转为结构体切片。
* 写单元测试（表驱动测试法），覆盖正常/异常路径。

**验收**

* `go test ./...` 全绿；`golangci-lint` 通过。

---

### 第 6 周：HTTP 服务 & 中间件

**要学的点**

* 用 `net/http` 或轻量框架（`chi`/`fiber`）写 REST API
* 中间件（日志、CORS、限流）、配置与环境变量、结构化日志（`zap`/`zerolog`）

**项目**

* 写一个 **Go“特征统计”服务**：

  * `POST /summary` 接收 CSV（或 JSON 数组），返回列级统计（均值/方差/缺失率/类别分布）。
  * `GET /health` 健康检查。
* 加上请求日志、错误统一包装、CORS（供前端直连调试）。

**验收**

* Dockerfile + `docker run` 能正常对外服务。
* `curl`/`httpie` 能测通；返回 JSON 有清晰错误字段。

---

### 第 7 周：并发 & 数据管道（goroutine + channel + context）

**要学的点**

* **goroutine/channel** 基础模型、**context** 取消与超时
* 扇入扇出、工作池（worker pool）、背压
* I/O 绑定任务的并发加速

**项目**

* 新建 Go **批量预处理服务**：

  * 读取一个大 CSV（或多个小 CSV），并发做：缺失值统计、异常值检测（如 3σ）、类型推断。
  * 支持 `?workers=N` 控制并发度；Context 超时中断。

**验收**

* 单机 10 万行 CSV 的处理明显快于单线程 Python（I/O 较多时差距明显）。
* 代码有**可控并发**、**超时**与**优雅退出**。

---

### 第 8 周：与 Python/TS 生态协同（gRPC/消息队列 可选）

**要学的点**

* 与 Python FastAPI 协作：

  * 方案 A：HTTP 同步调用
  * 方案 B（进阶）：**消息队列**（Redis/RabbitMQ）异步任务
  * 方案 C（进阶）：**gRPC**（.proto 契约，Go 做数据处理，Python 做模型推理）
* 简单**性能基准**与**火焰图**（`pprof`）定位热点

**项目**

* 把第 7 周的 Go 预处理服务接入到现有模板：

  * 前端 → FastAPI（Python）→ **调用 Go 服务** → 返回清洗后的数据 → 才送入模型推理。
  * 在 README 画出数据流图。

**验收**

* 一条端到端链路可跑通：上传 CSV →（Go 清洗）→（Python 推理）→ 前端展示。
* 有简单基准：每秒可处理多少行、并发 N 时的RT变化。

---

## 第 9–12 周：整合与进阶（把 Demo 打造成“作品”）

### 第 9 周：前端专业化（表格/可视化/交互）

* 引入高级表格（如虚拟滚动、筛选、导出）
* 可视化：预测分布 + 置信度 + 校准曲线（前端端算 or 后端返回）
* 统一样式（Tailwind 或 CSS Modules），组件库（可选）

**验收**

* 上传 CSV → 表格展示输入 & 预测 & 置信度；可下载结果 CSV。

---

### 第 10 周：服务治理（监控/日志/追踪）

* Python（Uvicorn/Gunicorn）与 Go 服务接入**结构化日志**
* **健康检查/就绪检查**（K8s 友好）
* 指标：请求耗时、错误率、队列长度（Evidently/Prometheus/Grafana 可择一了解）
* 错误上报（Sentry 或简易 webhook）

**验收**

* 本地 `docker compose up` 后，能看到基础指标或日志面板；错误路径可定位。

---

### 第 11 周：鉴权与简单多租户

* FastAPI：JWT（短期）+ 刷新（长期）
* 前端：拦截未登录请求、Token 自动注入、刷新/过期处理
* 最小多租户：按用户隔离其上传与结果（目录或表键）

**验收**

* 未登录用户无法调用推理；登录后有“我的历史预测”。

---

### 第 12 周：作品打磨 & 文档化

* 编写**系统设计文档**（数据流、模块依赖、异常处理、扩展点）
* 压测脚本（k6 或 simple wrk/httpx 脚本）
* 完整 README（含**一键启动**、**配置说明**、**API 契约**、**性能指标**、**截图/GIF**）

**验收（最终作品）**

* 一个仓库，包含：

  * `frontend/`（TS/Next）
  * `backend-python/`（FastAPI 推理）
  * `preproc-go/`（Go 并发清洗）
  * `docker-compose.yml`（一键起）
  * 文档与基准结果
* 可以作为**求职/答辩/项目展示**直接给人看。

---

### 学习配套清单（只记关键要点）

#### TypeScript 必修点（对你最有用）

* 类型体操只取“够用”集合：**泛型函数、条件类型、`infer`（了解即可）、类型收窄、`keyof`、索引访问类型**
* 实战习惯：**先定义类型，再写实现**；API 响应统一类型化；**禁止随手 `any`**
* Next.js：**App Router 心智模型**、组件拆分、错误/加载边界、环境变量、SSR/CSR 取舍

#### Go 必修点（对你最有用）

* **接口是隐式实现**、error 一等公民、方法接收者（值/指针）的取舍
* **goroutine + channel + context** 三件套；工作池与取消机制
* 结构化日志、配置与依赖注入（简易版即可），**表驱动测试**
* Docker 化、运行时参数化（env/flag）

---

### 每周时间分配建议（总 10–12 小时/周）

* **阅读/视频**：3 h（只看必要）
* **动手实现**：6 h（完成当周“在模板里做”的任务）
* **写文档/复盘**：1–2 h（记录踩坑、输出 README/注释）

---

### 进阶与选修（按需）

* **OpenAPI→TS 类型自动生成**，避免手写不一致
* **gRPC（Go↔Python）**：强契约、高性能
* **消息队列（Redis/RabbitMQ）**：异步批处理、重试/死信
* **容器编排（K8s + KEDA）**：推理弹性扩缩
* **数据湖/列存**：Go 写入 Parquet（`parquet-go`）+ DuckDB/ClickHouse 查询

---

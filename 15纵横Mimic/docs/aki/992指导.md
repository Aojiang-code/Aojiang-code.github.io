太好了，文档已经写好，现在可以正式“按图施工”了 🎯

下面是**详细的步骤 2**：我们会把 Step1 里写好的定义，翻译成两份可以直接放到 `backend/sql/` 里的 SQL 脚本：

1. `aki_cohort.sql`：生成 AKI 队列表（含人口学 + ICU 信息 + 结局）
2. `aki_labs_firstday.sql`：生成 AKI 患者首日实验室指标的汇总表（Scr/BUN/电解质等）

这样做完之后，你就可以在 Python 里：

* `SELECT * FROM aki_cohort;`
* `SELECT * FROM aki_labs_firstday;`

再 `merge` 两张表进入分析。

---

## 0. 小准备：约定与文件位置

我们假定你用的是 PostgreSQL + 标准 MIMIC-IV schema：

* ICU 表：`mimiciv_icu.icustays`
* 住院表：`mimiciv_hosp.admissions`
* 患者表：`mimiciv_hosp.patients`
* 诊断表：`mimiciv_hosp.diagnoses_icd`
* 实验室：`mimiciv_hosp.labevents` + `mimiciv_hosp.d_labitems`

建议在仓库里放：

```text
backend/
  sql/
    aki_cohort.sql
    aki_labs_firstday.sql
```

---

## 一、`aki_cohort.sql`：构建 AKI ICU 队列表

目标：根据你在 `01_cohort_definition.md` 和 `02_variable_dictionary.md` 里写的标准，生成一张 **“一行 = 1 个 AKI ICU 首次住院”** 的表或物化视图。

字段要覆盖你变量字典里的人口学、ICU 信息、ICU/住院结局。

### 1. 逻辑分解

我们按 4 步来：

1. 选出 **成人首次 ICU 入住**（每个 subject_id 只有一条 stay）
2. 加上患者和住院信息（年龄、性别、种族、保险等）
3. 在住院期间有 AKI 相关 ICD-9/10（584* 或 N17*）的，才保留
4. 排除 ICU 停留时间 < 6 小时

### 2. 推荐 SQL（可以直接保存为 `backend/sql/aki_cohort.sql`）

```sql
-- backend/sql/aki_cohort.sql

-- 视情况添加 search_path
-- SET search_path TO mimiciv_icu, mimiciv_hosp, public;

DROP MATERIALIZED VIEW IF EXISTS aki_cohort CASCADE;

CREATE MATERIALIZED VIEW aki_cohort AS
WITH icu_firststay_adult AS (
    -- 1）每位患者的首次ICU入住 + 成年人
    SELECT
        i.subject_id,
        i.hadm_id,
        i.stay_id,
        i.intime,
        i.outtime,
        i.first_careunit,
        ROW_NUMBER() OVER (
            PARTITION BY i.subject_id
            ORDER BY i.intime
        ) AS rn
    FROM mimiciv_icu.icustays i
    JOIN mimiciv_hosp.patients p
        ON i.subject_id = p.subject_id
    WHERE p.anchor_age >= 18  -- 成人
      AND p.anchor_age IS NOT NULL
),
icu_firststay_filtered AS (
    -- 2）只保留首次ICU + ICU住院时间 >= 6小时
    SELECT
        f.subject_id,
        f.hadm_id,
        f.stay_id,
        f.intime,
        f.outtime,
        f.first_careunit,
        EXTRACT(EPOCH FROM (f.outtime - f.intime)) / 3600.0 AS icu_los_hours
    FROM icu_firststay_adult f
    WHERE f.rn = 1
      AND f.outtime IS NOT NULL
      AND EXTRACT(EPOCH FROM (f.outtime - f.intime)) / 3600.0 >= 6.0
),
aki_admissions AS (
    -- 3）在住院期间有 AKI ICD 诊断的住院
    SELECT DISTINCT
        d.hadm_id
    FROM mimiciv_hosp.diagnoses_icd d
    WHERE
        (
            (d.icd_version = 9  AND d.icd_code LIKE '584%')  -- ICD-9 AKI
         OR (d.icd_version = 10 AND d.icd_code LIKE 'N17%')  -- ICD-10 AKI
        )
),
base_cohort AS (
    -- 4）将ICU首次入住 + AKI诊断 + 患者/住院信息 合并
    SELECT
        icu.subject_id,
        icu.hadm_id,
        icu.stay_id,
        icu.intime,
        icu.outtime,
        icu.first_careunit,
        icu.icu_los_hours,

        p.anchor_age AS age,
        p.gender,

        a.ethnicity,
        a.insurance,
        a.admittime,
        a.dischtime,
        a.deathtime,
        a.hospital_expire_flag
    FROM icu_firststay_filtered icu
    JOIN aki_admissions aki
        ON icu.hadm_id = aki.hadm_id
    JOIN mimiciv_hosp.patients p
        ON icu.subject_id = p.subject_id
    JOIN mimiciv_hosp.admissions a
        ON icu.hadm_id = a.hadm_id
)
SELECT
    -- ID 类变量
    subject_id,
    hadm_id,
    stay_id,

    -- 人口学
    age,
    gender,
    ethnicity,
    insurance,

    -- ICU信息
    intime,
    outtime,
    first_careunit,
    icu_los_hours,
    icu_los_hours / 24.0 AS icu_los_days,

    -- 住院信息
    admittime,
    dischtime,
    EXTRACT(EPOCH FROM (dischtime - admittime)) / 86400.0 AS hosp_los_days,

    -- 结局：ICU死亡 & 住院死亡
    CASE
        WHEN deathtime IS NOT NULL
             AND deathtime BETWEEN intime AND outtime
        THEN 1 ELSE 0
    END AS icu_mortality,

    hospital_expire_flag::int AS hosp_mortality
FROM base_cohort;
```

> 你以后如果想改成年龄 ≥ 16、ICU LOS ≥ 12 小时，只需要改这个脚本的 WHERE 条件即可，逻辑很集中。

---

## 二、`aki_labs_firstday.sql`：首日实验室指标汇总表

目标：为变量字典中的实验室指标（Scr、BUN、Na、K、WBC、Hb、PLT）生成**首日（ICU 入科后 0–24 小时）**的数值变量。

我们不在这个脚本里“死写 itemid”，而是推荐一个做法：

1. 先在 `d_labitems` 中根据 `label` 找到对应 `itemid`
2. 把这些 `itemid` 固定在一个小表/CTE 里（方便以后维护）
3. 从 `mimiciv_hosp.labevents` 里抽首日数据，按 stay_id + itemid 聚合（取中位数或均值）

### 1. 先找出 itemid（你在数据库里执行一次就好）

可以在 psql 里先跑一段：

```sql
SELECT itemid, label, fluid, category
FROM mimiciv_hosp.d_labitems
WHERE LOWER(label) IN (
    'creatinine',
    'urea nitrogen',
    'sodium',
    'potassium',
    'white blood cells',
    'hemoglobin',
    'platelet count'
)
ORDER BY label, itemid;
```

把查到的 itemid 记下来，等会儿填进下面脚本中的对应位置。

> 注意：MIMIC-IV 的实验室项目有时会有多个 itemid 对应相近 label（如不同单位或测量方式），
> 第一阶段你可以**手动挑一个最常用的**，后面再精细优化。

### 2. 推荐 SQL：`backend/sql/aki_labs_firstday.sql`

这个脚本的思路：

* 从 `aki_cohort` 出发（确保只针对 AKI ICU 患者）
* 关联 `labevents`，筛选 ICU 入科后 0–24 小时的记录
* 只保留我们关心的 itemid
* 按 stay_id 聚合成每个实验室 1 个数值（这里示范用中位数）

```sql
-- backend/sql/aki_labs_firstday.sql

DROP MATERIALIZED VIEW IF EXISTS aki_labs_firstday CASCADE;

CREATE MATERIALIZED VIEW aki_labs_firstday AS
WITH aki_base AS (
    -- 1）从已构建的 AKI 队列出发
    SELECT
        c.subject_id,
        c.hadm_id,
        c.stay_id,
        c.intime,
        c.outtime
    FROM aki_cohort c
),
lab_item_map AS (
    -- 2）手动填充或从 d_labitems 中选择需要的 itemid
    -- 下面的数字是占位符，请根据你在 d_labitems 查询的结果进行替换
    SELECT * FROM (VALUES
        (1001, 'scr_firstday'),  -- Creatinine
        (1002, 'bun_firstday'),  -- Urea nitrogen
        (1003, 'na_firstday'),   -- Sodium
        (1004, 'k_firstday'),    -- Potassium
        (1005, 'wbc_firstday'),  -- White blood cells
        (1006, 'hb_firstday'),   -- Hemoglobin
        (1007, 'plt_firstday')   -- Platelet count
    ) AS t(itemid, var_name)
),
aki_labs_raw AS (
    -- 3）提取 ICU入科后0-24小时内的实验室记录
    SELECT
        a.subject_id,
        a.hadm_id,
        a.stay_id,
        l.itemid,
        l.valuenum,
        l.charttime
    FROM aki_base a
    JOIN mimiciv_hosp.labevents l
        ON a.hadm_id = l.hadm_id
    JOIN lab_item_map m
        ON l.itemid = m.itemid
    WHERE
        l.valuenum IS NOT NULL
        AND l.charttime >= a.intime
        AND l.charttime <  a.intime + INTERVAL '24 hours'
),
aki_labs_agg AS (
    -- 4）对每个 stay_id + itemid 聚合：这里示例用中位数
    SELECT
        r.stay_id,
        r.itemid,
        percentile_disc(0.5) WITHIN GROUP (ORDER BY r.valuenum) AS lab_median
    FROM aki_labs_raw r
    GROUP BY r.stay_id, r.itemid
),
aki_labs_pivot AS (
    -- 5）将多行（不同itemid）转换为一行（列形式）
    SELECT
        b.subject_id,
        b.hadm_id,
        b.stay_id,

        -- 逐个变量 CASE WHEN + MAX 实现 pivot
        MAX(CASE WHEN m.var_name = 'scr_firstday' THEN a.lab_median END) AS scr_firstday,
        MAX(CASE WHEN m.var_name = 'bun_firstday' THEN a.lab_median END) AS bun_firstday,
        MAX(CASE WHEN m.var_name = 'na_firstday'  THEN a.lab_median END) AS na_firstday,
        MAX(CASE WHEN m.var_name = 'k_firstday'   THEN a.lab_median END) AS k_firstday,
        MAX(CASE WHEN m.var_name = 'wbc_firstday' THEN a.lab_median END) AS wbc_firstday,
        MAX(CASE WHEN m.var_name = 'hb_firstday'  THEN a.lab_median END) AS hb_firstday,
        MAX(CASE WHEN m.var_name = 'plt_firstday' THEN a.lab_median END) AS plt_firstday
    FROM aki_base b
    LEFT JOIN aki_labs_agg a
        ON b.stay_id = a.stay_id
    LEFT JOIN lab_item_map m
        ON a.itemid = m.itemid
    GROUP BY
        b.subject_id,
        b.hadm_id,
        b.stay_id
)
SELECT * FROM aki_labs_pivot;
```

> 这样你将得到一张：
> `aki_labs_firstday(subject_id, hadm_id, stay_id, scr_firstday, bun_firstday, ..., plt_firstday)` 的表，
> 与 `aki_cohort` 可以用 `(stay_id)` 或 `(subject_id, hadm_id, stay_id)` 直接 join。

---

## 三、Step2 做完后，你可以在数据库里做的自检

当你把这两个 SQL 文件运行完（例如在 psql 里 `\i backend/sql/aki_cohort.sql`，然后 `\i backend/sql/aki_labs_firstday.sql`）之后，可以做几件小检查：

1. 看队列表大小 & 基本信息：

```sql
SELECT COUNT(*) FROM aki_cohort;
SELECT MIN(age), MAX(age) FROM aki_cohort;
SELECT gender, COUNT(*) FROM aki_cohort GROUP BY gender;
SELECT AVG(icu_los_days), AVG(hosp_los_days) FROM aki_cohort;
SELECT AVG(icu_mortality), AVG(hosp_mortality) FROM aki_cohort;
```

2. 看实验室表与队列表的匹配：

```sql
SELECT COUNT(*) FROM aki_labs_firstday;
SELECT COUNT(DISTINCT stay_id) FROM aki_labs_firstday;
SELECT COUNT(*) FROM aki_cohort c
LEFT JOIN aki_labs_firstday l ON c.stay_id = l.stay_id
WHERE l.stay_id IS NULL;
-- 看看有多少AKI ICU病人没有任意一项首日实验室（正常会有一些缺失）
```

3. 随机抽几行看看：

```sql
SELECT * FROM aki_labs_firstday ORDER BY random() LIMIT 5;
```

如果这些都能跑通，说明 Step2 已经 **从“文档”变成了真实的 SQL 管道** ✅

---

## 接下来可以怎么走？

等你：

* 运行完这两个 SQL 脚本
* 确认 `aki_cohort` 和 `aki_labs_firstday` 都存在、行数合理

我们就可以进入你计划的 **步骤 3（Python 分析）**：

* 在 Notebook 里用 `pandas.read_sql("SELECT * FROM aki_cohort ...")` 读入
* 合并实验室指标
* 生成 Table 1 + 年龄/性别/死亡率的 JSON 结果，给前端用

如果你愿意，下一步我可以帮你写：

* `01_aki_cohort_explore.ipynb` 的“伪代码结构”（包括连接数据库、合并 labs、做 Table 1）
* 再给你一套导出 JSON 的推荐格式（比如 `aki_age_distribution.json` 的具体键名设计）

好，正式进入 **A1 阶段：Scr 时间序列视图** 🚀
这一轮我们先把 **Scr 时间序列 `aki_scr_timeseries` 做完整、可用**，尿量（UO）先留接口，后面再精细化。

---

## 🎯 A1 总目标（这一步结束时你应该拥有的东西）

* 数据库里多了一张 **物化视图**：

  ```sql
  mimiciv_icu.aki_scr_timeseries
  ```

* 它包含每个 AKI ICU 患者的 **Scr 时间序列**，字段包括：

  * `subject_id`
  * `hadm_id`
  * `stay_id`
  * `charttime`
  * `hours_from_icu_intime`（相对于 ICU 入科时间的小时数，负数 = ICU 之前）
  * `scr_mg_dl`（统一用 mg/dL）

* 这将是后续 **KDIGO 实现的底座**。

---

## ① 在项目中写好 SQL 文件

路径我们约定为：

```bash
/public/home/aojiang/mimic/15纵横Mimic/backend/sql/aki/aki_scr_timeseries.sql
```

请在终端执行：

```bash
cd /public/home/aojiang/mimic/15纵横Mimic/backend/sql/aki
```

用你习惯的编辑方式（vim/nano/VS Code remote 等）打开：

```bash
aki_scr_timeseries.sql
```

把下面这段 **完整替换/写入** 到文件中（可以直接复制粘贴）：

```sql
-- aki_scr_timeseries.sql
-- AKI ICU 患者的血清肌酐（Scr）时间序列
-- 依赖：
--   - mimiciv_icu.aki_cohort
--   - mimiciv_hosp.labevents

DROP MATERIALIZED VIEW IF EXISTS mimiciv_icu.aki_scr_timeseries CASCADE;

CREATE MATERIALIZED VIEW mimiciv_icu.aki_scr_timeseries AS
SELECT
    c.subject_id,
    c.hadm_id,
    c.stay_id,
    l.charttime,
    -- 相对于 ICU 入科时间的小时数（可用于 KDIGO 时间窗）
    EXTRACT(EPOCH FROM (l.charttime - c.intime)) / 3600.0 AS hours_from_icu_intime,
    -- Scr 数值（单位假定为 mg/dL，后续可在 d_labitems 中验证）
    l.valuenum AS scr_mg_dl
FROM mimiciv_icu.aki_cohort AS c
JOIN mimiciv_hosp.labevents AS l
    ON c.hadm_id = l.hadm_id
WHERE
    -- Creatinine 的 itemid（MIMIC-IV v2.2 官方文档：Creatinine = 50912）
    l.itemid = 50912
    AND l.valuenum IS NOT NULL
    -- 时间范围：住院前 7 天 ~ 出院后 1 天（给基线 + 恢复预留空间）
    AND l.charttime BETWEEN (c.admittime - INTERVAL '7 days')
                        AND (c.dischtime + INTERVAL '1 day');
```

> 说明：
>
> * 这里 *没有* 依赖 `search_path`，所有表都写了 schema 前缀（`mimiciv_icu. / mimiciv_hosp.`）。
> * 物化视图放在 `mimiciv_icu` 下面，与你现有的 `aki_cohort` 一致。

---

## ② 在 psql 中执行这个 SQL 文件

回到你的 psql 环境（注意要连 **mimiciv** 数据库）：

```bash
psql -U mimicuser -d mimiciv
```

确认提示符是：

```text
mimiciv=>
```

然后执行：

```sql
SET search_path TO mimiciv_icu, mimiciv_hosp, public;

\i /public/home/aojiang/mimic/15纵横Mimic/backend/sql/aki/aki_scr_timeseries.sql
```

如果一切正常，你会看到类似输出：

```text
DROP MATERIALIZED VIEW
SELECT  ........................
```

（`SELECT` 后面的数字是写入物化视图的行数，不用太纠结具体数值，多则几百万都正常。）

---

## ③ 验证 Scr 时间序列视图是否创建成功

在 psql 中依次执行：

```sql
-- 1. 看一下物化视图是否存在
\dm aki_scr_timeseries

-- 2. 统计行数（大概数量，看有没有数据）
SELECT COUNT(*) FROM mimiciv_icu.aki_scr_timeseries;

-- 3. 抽样查看前几行
SELECT *
FROM mimiciv_icu.aki_scr_timeseries
ORDER BY stay_id, charttime
LIMIT 20;
```

你应该看到：

* `\dm` 输出一行类似：

  ```text
  Schema     |       Name          |       Type        | Owner
  -----------+---------------------+-------------------+---------
  mimiciv_icu| aki_scr_timeseries  | materialized view | mimicuser
  ```

* `COUNT(*)` 是一个比较大的数（因为一人会有多次 Scr 测量，18k 个 stay × 多个时间点）；

* `SELECT * LIMIT 20` 里能看到：

  * 每行有 stay_id、charttime、hours_from_icu_intime、scr_mg_dl；
  * `hours_from_icu_intime` 有可能是负数（在 ICU 入科之前），这是我们期望的。

---

## ④ 小结：A1 的 Scr 部分完成标准

当你满足下面 3 条，就说明 **A1-Scr 子任务已经完成 ✅**：

1. `\dm aki_scr_timeseries` 能看到这个物化视图；
2. `SELECT COUNT(*) FROM mimiciv_icu.aki_scr_timeseries;` 给出一个 >0 的非空结果；
3. 抽样行中 `scr_mg_dl` 看起来像正常 Scr（例如 0.3–20 之间，而不是 3000 这种明显单位问题）。

> 尿量 `aki_uo_timeseries` 我们可以放在下一小步（A1-UO）再做，
>
> > 先把 Scr 做稳定，因为 KDIGO v1 我们只用 Scr 就能跑起来。

---

## ⑤ 你接下来可以做什么？

1. **现在就按上面的步骤创建并检查 `aki_scr_timeseries`。**

   * 如果过程中出现任何报错，把终端输出贴给我，我们一起 debug。
2. **一旦 Scr 时间序列视图稳定，我们就可以在 A2 里开始实现 KDIGO：**

   * 先在 Python 里加载 `aki_scr_timeseries`；
   * 按 stay_id 计算 baseline Scr；
   * 进而计算每个时间点的 KDIGO stage，并生成 `aki_kdigo_summary`。

---

你可以先去执行上面的 psql + SQL 文件这几步。
等你完成（或者遇到报错），把结果贴出来，我就带你进 A2（KDIGO 真正上线的那一步）。

## 指令

我们先做路线 A：继续扩展 AKI（从 ICD → KDIGO → 回归模型）

我们先把路线A做到极致，我们不止做回归模型，做完回归模型，我们还要做机器学习，甚至轨迹模型，甚至更复杂的模型

完成上述任务之后，我们再完成路线 D：完善数据库体系（加入索引、物化视图刷新、自动化脚本）

我认为路线D可以让我们之后扩展其他疾病任务时提高效率

完成上述两条路线后，我们再做一个极致美观的前端，也就是路线 C：升级前端（ECharts → React / Next.js 仪表盘）

最后我们再进行路线 B：复制模板做第二个疾病，但是我们还是做一个肾内科的疾病，之后再扩展到其他科室的疾病

现在，请你按照上述路线顺序，给我出一份指导大纲。你先完成这份大纲，之后我们会按照这份大纲
，给不同的路线，写下更加详细的计划方案



好的，我们就按你定的路线来搭一个“总蓝图”。下面这份是 **总指导大纲**，后面我们会围绕它给每一条路线写细化方案。

---

## 总体思路（大家伙）

* 统一名字：整个项目就叫 **MIMIC-AKI 平台**。
* 总仓库分层：

  * `backend/`：SQL + Python（数据、KDIGO、建模）。
  * `frontend/`：可视化（先 ECharts，后 Next.js）。
  * `docs/`：设计文档、方案、实验记录。
* 所有路线都遵守同一原则：

  1. **先文档 → 再代码 → 再结果 → 再写总结。**
  2. 每条路线都以 **“可复现 + 可视化 + 可讲故事”** 为终点。

路线顺序：
**A（AKI深化） → D（数据库基础建设） → C（前端升级） → B（第二个肾内疾病）**

---

## 路线 A：AKI 深化（ICD → KDIGO → 回归 → 机器学习 → 轨迹模型）

### A0. 目标 & 文档

* 在 `docs/aki/` 里新增：

  * `03_kdigo_definition.md`
  * `04_modeling_plan.md`
* 明确：

  * 用哪版 KDIGO（Scr + Urine + 时间窗）。
  * 预测任务：如 ICU 死亡、住院死亡、RRT、AKI 进展等。
  * 模型层级：传统回归 → ML → 时间序列/轨迹模型。

---

### A1. KDIGO AKI 识别（基础工程）

**A1.1 数据准备（SQL 为主）**

* 提取 **Scr 时间序列**（住院/ICU 全程）：

  * 来自 `mimiciv_hosp.labevents`，所有 `Creatinine` itemid。
* 提取 **尿量时间序列**（ICU 内）：

  * 来自 `mimiciv_icu.outputevents` 等。
* 把这些做成物化视图：

  * `aki_scr_timeseries`
  * `aki_uo_timeseries`

**A1.2 基线 Scr & KDIGO 规则实现**

* 在 `docs/aki/03_kdigo_definition.md` 里写清楚：

  * 基线 Scr 算法（如：最近一次非 ICU Scr、最低 Scr、MDRD 反推等）。
  * KDIGO 阈值（日内/48h/7天）。
* SQL 或 Python 实现一个 **KDIGO 打标签函数**：

  * 对每个 stay，输出：

    * `kdigo_stage_max`
    * `kdigo_onset_time`
    * `kdigo_stage_over_time`（按小时/天的序列）。

**A1.3 结果校验**

* 随机抽样若干病人：

  * 手工画 Scr 曲线 + 自动 KDIGO stage 曲线，看是否符合预期。
* 在 `docs/aki/03_kdigo_definition.md` 中记录：

  * 常见边界情况（Scr 缺失、住院前已有 CKD、短住院等）。
  * 已知问题 & 暂时的取舍。

---

### A2. KDIGO 表型化 & 变体

* 新建物化视图或表：

  * `aki_kdigo_summary`：

    * `first_stage`、`max_stage`、`progression(是否进展)`、`recovery(是否恢复)`、`persistent_aki` 等。
* 统计：

  * KDIGO 分期分布。
  * 不同表型（如 RRT vs no RRT，快速恢复 vs 持续 AKI）数量与结局。
* 输出 JSON / CSV，为后续建模 & 前端使用。

---

### A3. 建模数据集（Feature Store v0）

**A3.1 预测任务定义**

* 例如：

  * **任务 1**：入 ICU 后 24h 内特征 → 预测 ICU 死亡。
  * **任务 2**：AKI 发生后 24h 内特征 → 预测是否进展到 Stage 3。
* 文档中明确：

  * 预测时间点（T0）。
  * 特征时间窗（如 T0 前 24h）。
  * 预测窗（如 T0 后 7天内是否死亡）。

**A3.2 特征构造**

* 特征类别：

  * 人口学：age, gender, race, insurance。
  * 基础病：Charlson Score / comorbidity flags（另一个 SQL）。
  * 检验：Scr/BUN/Na/K/WBC/Hb/PLT + 统计量（首日、最大、变化率）。
  * 生命体征：HR/MAP/SpO2/Resp（按 ICU 前24h）。
* 生成建模表：

  * `aki_ml_dataset`：

    * 一行一个 stay：

      * `stay_id` + 特征列 + 结局列 + KDIGO 信息。

---

### A4. 传统回归模型（基线）

**A4.1 Logistic / Cox 模型**

* 用 `aki_ml_dataset`：

  * Logistic 回归 → ICU/住院死亡。
  * 若做时间到事件 → Cox 模型。
* 关注：

  * OR/HR + 95% CI。
  * 多重共线性、线性假设等。

**A4.2 文档与结果输出**

* 写 `docs/aki/04_modeling_plan.md` 中的：

  * 模型公式、变量选择逻辑。
  * 回归结果表（Table：OR / p 值）。
* 输出：

  * `aki_logistic_results.json`
  * `aki_cox_results.json`
  * 供前端展示（如森林图）。

---

### A5. 机器学习模型（ML）

**A5.1 基础模型**

* 使用：

  * Logistic + L1/L2（作为 baseline ML）
  * Random Forest
  * XGBoost / LightGBM
* 做：

  * 训练 / 验证 / 测试划分（可按时间、病人级别）。
  * 5-fold CV 或 nested CV。

**A5.2 评估与可视化**

* 指标：

  * AUROC、AUPRC。
  * Calibration curve（校准）。
  * Brier score。
* 输出：

  * `aki_ml_metrics.json`
  * `aki_feature_importance.json`（支持 Shapley 等）。

---

### A6. 轨迹模型 / 时间序列（进阶）

**A6.1 时间序列数据准备**

* 为每个 stay 构造：

  * Scr 时间序列（例如 ICU 前7日，按 6 小时间隔）。
  * 或多变量（Scr, UO, MAP, Lactate）。
* 存放表：

  * `aki_ts_scr`、`aki_ts_multi`.

**A6.2 轨迹分析方法**

可以按难度递增：

1. 简单：

   * 使用层次聚类 / DTW + 聚类，对 Scr 轨迹分型。
2. 中级：

   * Group-Based Trajectory Model（GBTM；R 里有成熟包）。
3. 进阶：

   * RNN/LSTM/Transformer 进行时间序列预测或 representation learning。

**A6.3 将轨迹类型整合回建模数据集**

* 给每个患者加一个 `trajectory_cluster` 或 `latent_class`，再做：

  * 回归/ML：看不同轨迹亚型与结局的关系。

---

### A7. 实验管理 & 复现性

* 引入：

  * `experiments/aki/` 目录，保存每次实验配置（YAML）和结果。
  * 使用 MLflow / simple logging（CSV + JSON）。
* 每一类模型写一个小节：

  * 版本号、特征集、样本定义、主要结果。

---

## 路线 D：数据库基础建设（索引、物化视图刷新、自动化）

> 这条路线是给整个“AKI + 未来多个疾病模块”打“水电煤”的。

### D1. 现有查询的性能评估

* 记录常用 SQL：

  * 建模数据提取 SQL。
  * KDIGO 相关 SQL。
* 使用 `EXPLAIN ANALYZE` 看瓶颈。
* 文档：`docs/db/00_performance_baseline.md`。

---

### D2. 索引设计

* 对关键字段增加索引：

  * 原始表：`subject_id`, `hadm_id`, `stay_id`, `charttime`。
  * AKI 相关视图：`aki_cohort(stay_id)`, `aki_labs_firstday(stay_id)`, `aki_kdigo_summary(stay_id)`.
* 形成 SQL 脚本：

  * `backend/sql/indexes/create_core_indexes.sql`
* 测试索引前后性能差异，记录在文档中。

---

### D3. 物化视图刷新策略

* 为每一个物化视图定义：

  * 刷新频率（如：全量重建 / 按天增量）。
* 写一个统一的刷新脚本：

  * `backend/sql/refresh_all_mviews.sql`
* 写一个 Python CLI：

  * `python -m backend.db.refresh_all`

    * 内部调用 `REFRESH MATERIALIZED VIEW …`。

---

### D4. 自动化与“一键重建”

* 用 Makefile 或 Python CLI，支持：

  ```bash
  make rebuild-aki-db
  # 或
  python -m backend.cli rebuild_aki_metadata
  ```

* 功能：

  * 建索引。
  * 创建/刷新物化视图。
  * 生成建模数据集（可选）。

---

## 路线 C：前端升级（ECharts → React / Next.js 仪表盘）

> 在 A & D 夯实后，把“内容”变成真正好看的“产品”。

### C1. 前端架构重构

* 新建 `frontend-next/`：

  * 基于 **Next.js + TypeScript**。
* 路由结构：

  * `/` → 总览（项目首页）。
  * `/aki` → AKI 仪表盘。
  * 未来 `/aki/kdigo`, `/aki/ml`, `/aki/trajectory` 等子页。

---

### C2. 设计系统 & 交互

* 定义：

  * 颜色、字体、组件风格（“医学仪表盘”风格）。
* 封装组件：

  * `<SummaryCard />`，`<MetricTrend />`，`<AkiStageChart />`。
* 使用 ECharts 或其他图表库（如 Recharts、AntV G2）接入 React。

---

### C3. 与后端数据的联动

* 现阶段继续用静态 JSON（通过 `getStaticProps` 或直接 fetch `/data/aki/xxx.json`）。
* 预留接口：

  * 将来可以改为 API 方式（例如 `api/aki/summary`）。

---

### C4. 多模型结果展示

* 回归模型：森林图、表格。
* ML 模型：ROC 曲线、校准曲线、特征重要性条形图。
* 轨迹模型：不同轨迹子群的 Scr 曲线 / Sankey / Cluster 图。

---

## 路线 B：第二个肾内科疾病模块（模板复制 & 扩展）

> 在 A+D+C 稳定后，用同一套框架快速扩展新的疾病。

### B1. 疾病选择 & 文档

* 在 `docs/` 新建：

  * `hf/00_study_design.md` 或 `ckd/00_study_design.md`（根据你选的疾病）。
* 明确：

  * 队列定义（ICD / lab / procedure）。
  * 主要结局。
  * 与 AKI 模块共享哪些变量。

---

### B2. 后端模板复制

* 以 AKI 为模板复制：

  * SQL：`backend/sql/hf_cohort.sql` 等。
  * Python：`backend/hf/` 目录，与 `backend/aki/` 结构对应。
* 保持：

  * 相同的 pipeline 入口：`python -m backend.hf.run_hf_pipeline`。

---

### B3. 模型与可视化整合

* 按路线 A 的思路，为新疾病完成：

  * Cohort + Labs + KDIGO-like 定义（如果适用）。
  * 回归 / ML 模型。
* 前端增加：

  * 新页面 `/hf` 或 `/ckd`。
  * 导航栏可以在 AKI / 新疾病之间切换。

---

## 小结

1. **先把 AKI 做到极致（路线 A）**：

   * KDIGO → 表型 → 回归 → ML → 轨迹模型 → 完整文档 & 输出。

2. **再通过路线 D 把数据库打造成“研究基础设施”**：

   * 索引、物化视图刷新、一键重建。

3. **然后使用路线 C 把前端升级成专业仪表盘**：

   * Next.js + 组件化图表，多页面路由。

4. **最后通过路线 B 把这一整套框架复用到第二个肾内疾病**，形成“肾内疾病数据产品群”。

---

如果你愿意，下一步我们就可以从 **路线 A 的第一个节点 A0 / A1 开始**：

> 先写好 `03_kdigo_definition.md` 的结构，然后一起设计 KDIGO 标注 SQL / Python 的骨架。

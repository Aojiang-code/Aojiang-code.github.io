# 8分类数据分析（卡方检验）
> 泰坦尼克号的死亡记录告诉了我们什么？

1912年4月15日，豪华巨轮泰坦尼克号与冰山相撞后沉没。1985年，泰坦尼克号的沉船遗骸被发现。美国探险家洛维特在船舱里看见了一幅画，102岁高龄的罗丝声称她就是画中的少女。

罗丝开始叙述她当年的故事：1912年4月10日，被称为“世界工业史上的奇迹”的泰坦尼克号从英国的南安普顿出发驶往美国纽约。富家少女罗丝与母亲及未婚夫卡尔一道上船，另一边，不羁的少年画家杰克靠在码头上的一场赌博赢到了船票。罗丝不愿意嫁给卡尔，打算投海自尽，被杰克抱住。很快，美丽活泼的罗丝与开朗的杰克相爱了。然而悲剧发生了，泰坦尼克号与冰山相撞。杰克把生存的机会让给了爱人罗丝，自己则在海中被冻死。

老太龙钟的罗丝把那串价值连城的珠宝沉入海底，让它陪着杰克和这段爱情长眠海底。

我们后来看到的电影《泰坦尼克号》就是根据罗丝的回忆拍摄的。

据记载，当时船上有1316名乘客和892名船员，共计2208人，事故发生后幸存718人，月2/3的人在海难中丧生。

**2208人中，**
>  按性别划分
>  - 男性1738人
>  - 女性470人

> 按年龄划分
> - 成年人2099人
> - 儿童109人

> 按所在仓位划分
> - 一等舱325人
> - 二等舱285人
> - 三等舱706人
> - 船员仓892人


**在幸存的718人中，**
>  按性别划分
>  - 男性374人
>  - 女性344人

> 按年龄划分
> - 成年人661人
> - 儿童57人

> 按所在仓位划分
> - 一等舱203人
> - 二等舱118人
> - 三等舱178人
> - 船员仓219人

以上都是**分类数据**。

数据是枯燥的，但讲述的问题却是鲜活的。死亡与性别是否有关？与年龄是否有关？与所在舱位是否有关？如何解释这些关系？当时人们的价值观念和对待死亡的态度有什么联系？

接下来，为您解答。

本节介绍的统计方法主要用于分类数据的分析。

我们在上一节中介绍了两个总体比例之差的检验，如果对更多的总体比例进行比较，则需要采用本节介绍的方法。对分类数据进行分析的统计方法主要是利用$χ^{2}$检验。

> $χ^{2}$检验的应用主要表现在两个方面：**拟合优度检验**和**独立性检验**。

> **列联表**是进行独立性检验的重要工具。


## 分类数据与$χ^{2}$统计量
### 分类数据
统计数据的类型有分类数据和数值型数据。
- 分类数据是对事物进行分类的结果，其特征是，调查结果虽然用数值表示，但不同的数值描述了调查对象的不同特征。
> 例如，
> 研究青少年家庭状况与行为之间的关系，
> 青少年家庭状况是一个分类数据，可以分为“完整家庭”和“离异家庭“，如果调查结果为”1“，表示被调查者来自完整家庭，调查结果为”2“，则表示被调查者来自离异家庭。
> 青少年行为也可以分为两类，”犯罪“和”未犯罪“，分别用”1“和”2“表示。

**对这类问题是在汇总数据的基础上进行分析的，数据汇总的结果表现为频数。**

**分类数据的结果是频数，$χ^{2}$检验是对分类数据的频数进行分析的统计方法。**


在前面泰坦尼克号海难的例子中，当时船上共2208人，其中男性1738人，女性470人。
海难发生后，幸存者718人，其中男性374人，女性344人。
这里，性别是分类变量，有两个类别：男性和女性；幸存的男性374人和女性344人都是事件结果，以频数的方式表现。

由第1章的讨论我们还知道，在一些问题的研究中，数值型数据可以转化为分类数据。
例如，“收入”是一个数值型数据，但如果研究收人分配，则可以按照一定的标准把不同收入的被调查者分为不同的类型，如“高收入群”“较高收入群”“中等收入群”等。各收入群的统计结果就是频数。

由上述内容可知，**分类数据的结果是频数，2检验是对分类数据的频数进行分析的统计方法**。

### $χ^{2}$统计量
在前文中对$χ^{2}$分布已经有所介绍，这里结合本章研究的问题，讨论$χ^{2}$统计量的应用。$χ^{2}$可以用于测定两个分类变量之间的相关程度。若用$f_{o}$表示观察值频数(observed frequency)，用$f_{e}$表示期望值频数（expected frequency)，则统计量可以
写为：
$$χ^{2}=\sum{\frac{{(f_{o}-f_{e})}^2}{f_{e}}}$$
$χ^{2}$统计量有如下特征：
- 首先，$χ^{2}$≥0，因为它是对平方结果的汇总；
- 其次，$χ^{2}$统计量的分布与自由度有关；
- 最后，统计量描述了观察值与期望值的接近程度。两者越接近，即$(f_{o}-f_{e})$的绝对值越小，计算出的$χ^{2}$值就越小；反之，$(f_{o}-f_{e})$的绝对值越大，计算出的$χ^{2}$值也越大。

$χ^{2}$检验正是通过对$χ^{2}$的计算结果与$χ^{2}$分布中的临界值进行比较，作出是否拒绝原假设的统计决策。
$χ^{2}$分布与自由度的关系如下图所示。下图显示了自由度分别为1,5和10时相应的$χ^{2}$分布。
![[Pasted image 20230916160616.png|450]]

由上图看出,自由度越小,分布越向左边倾斜,随着自由度的增大,分布的偏斜程度逐渐显露出对称性，随着自由度继续增大，$χ^{2}$分布将趋于对称的正态分布。利用$χ^{2}$统计量，可以对分类数据进行拟合优度检验和独立性检验。

## 拟合优度检验
拟合优度检验（goodness of fit test）是用$χ^{2}$统计量进行统计显著性检验的重要内容之一。
它是依据总体分布状况，计算出分类变量中各类别的期望频数，与分布的观察频数进行对比，判断期望频数与观察频数是否有显著差异，从而达到对分类变量进行分析的目的。

例如，在泰坦尼克号的例子中，我们关注在这次海难中幸存者的性别是否有显著差异。
当时船上共有2208人，其中男性1738人，女性470人。
海难发生后，幸存者共718人，其中男性374人，女性344人。
海难后存活比率为718/2208=0.325。

如果是否活下来与性别没有关系，那么按照这个比率，在1738位男性中应该存活1738×0.325=565人，在470位女性中应该存活470×0.325=153人。
565和153就是期望频数，而实际存活结果就是观察频数。
通过期望频数和观察频数的比较，能够从统计角度作出存活与性别是否有关的判断。

下面我们把这个例子作为一个假设问题提出。

>1912年4月15日，豪华巨轮泰坦尼克号与冰山相撞沉没。当时船上共有2208人，其中男性1738人，女性470人。海难发生后，幸存者共718人，其中男性374人，女性344人，以$α=0.1$的显著性水平检验存活状况与性别是否有关。
>
>解:
在本例中需要判断观察频数与期望频数是否一致。
Ho:观察频数与期望频数一致
H1:观察频数与期望频数不一致
依据式$χ^{2}=\sum{\frac{{(f_{o}-f_{e})}^2}{f_{e}}}$，可以将$χ^{2}$值的计算过程列表如下。

|      | $f_{o}$ | $f_{e}$ | 步骤一<br>$(f_{o}-f_{e})$ | 步骤二<br>$(f_{o}-f_{e})^{2}$ | 步骤三<br>$\frac{{(f_{o}-f_{e})}^2}{f_{e}}$ |
| ---- | ------- | ------- | ------------------------- | ----------------------------- | ------------------------------------------- |
| 男性 | 374     | 565     | -191                      | 36481                         | 64.6                                        |
| 女性 | 344     | 153     | 191                       | 16481                         | 238.4                                       |
|  步骤四   $χ^{2}=\sum{\frac{{(f_{o}-f_{e})}^2}{f_{e}}}=303$ |         |         |                           |                               |                                             |


表中第一行数据为男性数据,观察频数374,期望频数565,第二行为女性数据,观
察频数344，期望频数153。表9-1可以反映x2值的计算过程：
步骤一：计算$(f_{o}-f_{e})$;
步骤二：计算$(f_{o}-f_{e})^{2}$;
步骤三：计算$\frac{{(f_{o}-f_{e})}^2}{f_{e}}$;
步骤四：计算$χ^{2}=\sum{\frac{{(f_{o}-f_{e})}^2}{f_{e}}}$
自由度的计算公式为$df=R-1$,$R$为分类变量类型的个数。在本例中，分类变量是性别，有男、女两个类别，故$R=2$,于是自由度$df=2-1=1$,经查x2分布表，$χ^{2}_{0.1}(1)=2.706$,括号中的数字表示自由度。因为$χ^{2}$远大于$χ^{2}_{0.1}$，故拒绝$H_{0}$,接受$H_{1}$,说明存活状况与性别显著相关。


★用Excel计算P值的操作步骤
第1步：将观察值输入一列，将期望值输入一列。
第2步：进入Excel表格界面，选择【插入】下拉菜单。
第3步：选择【函数】，或者直接点击功能栏中的【fx】。
第4步：在函数类别选择中选“统计"，然后，在函数名的菜单中选择字符"CHISQ.TEST"，然后点击【确定】。
第5步：在对话框【Actual_range】中输入观察数据。在对话框【Expected_range】中输入期望数据。
第6步：点击【确定】得到P值为$7.2923×10^{-68}$，接近零。由于$P<α$ ,所以拒绝原假设。


同样的方法还可以用于对泰坦尼克号这个例子中的年龄、舱位情况进行检验。
结果表明，儿童存活率高于成人，一等舱、二等舱存活率高于船员舱。对这些结果的深层次分析，或许有助于我们认识当海难发生时，人们对待死亡的态度。

## 列联分析：独立性检验
拟合优度检验是对一个分类变量的检验，有时我们会遇到两个分类变量的问题，看这两个分类变量是否存在联系。例如，原料有不同的等级，原料又产自不同的地区。原料等级和原料生产地就是两个分类变量。我们关心这两者是否有关联，是不是某些地区生产的原料有更好的质量。对两个分类变量的分析，称为独立性检验，分析过程可以通过列联表的方式呈现，故有人把这种分析称为列联分析。

#### 列联表
列联表(contingency table)是将两个以上的变量进行交叉分类的频数分布表。例如，欲分析原料的质量是否与生产地有关，将500件随机抽取的原料按质量和产地构造列联表如下

| 地区 | 一级 | 二级 | 三级 | 合计 |
| ---- | ---- | ---- | ---- | ---- |
| 甲   | 52   | 64   | 24   | 140  |
| 乙   | 60   | 59   | 52   | 171  |
| 丙   | 50   | 65   | 74   | 189  |
| 合计     |   162   |    188  |    150  |   500   |

==源文件链接为==：[**（9-1）本章例题数据**](https://flowus.cn/aojiang/share/026c313f-2e4b-4d21-be17-187663ca70de)



表中的行(row)是生产地变量，这里划分为三类：甲、乙、丙三个地区。
表中的列(column)是原料等级变量，这里也划分为三类：一级、二级、三级。
因此，该表是一个3×3列联表,表中的每个数据都反映了生产地和原料等级两个方面的信息。由于列联表中的每个变量都可以有两个或两个以上的类别，列联表会有多种形式。
不妨将横向变量(行)的划分类别视为R,纵向变量（列）的划分类别视为C,这样可以把每一个具体的列联表称为RXC列联表，如把上表称为3×3列联表。

#### 独立性检验(卡方检验)（$χ^{2}$检验）
独立性检验就是分析列联表中行变量和列变量是否相互独立，在上表中，也就是检验各个地区和原料质量之间是否存在依赖关系。



> 一种原料来自三个不同的地区，原料质量被分成三个不同等级。
> 从这批原料中随机物取500件进行检验,结果如上表所示,要求检验各个地区和原料等级之间是否存在依赖关系($α=0.05$)。

>解

>
$H_{0}$:地区和原料等级之间是独立的（不存在依赖关系）
$H_{1}$:地区和原料等级之间不独立(存在依赖关系)

这里分析的关键是获得期望值。
在第一行，甲地区的合计为140，用140/500作为甲地区原料比例的估计值。
在第一列，一级原料的合计为162，用162/500作为一级原料比例的估计值。

如果地区和原料等级之间是独立的,则可以用下面的公式估计第一个单元(甲地区,一级)中的期望
比例。

令：
A=样本单位来自甲地区的事件
B=样本单位属于一级原料的事件
根据独立性的概率乘法公式，有

P(第一个单元)  =P(AB)
						=P(A)P(B)
						=$(\frac{140}{500})(\frac{162}{500})$
						$=0.09072$
						
$0.09072$是第一个单元中的期望比例，相应的频数期望值为：
$0.09072×500=45.36$
一般地，可以采用下式计算任何一个单元中频数的期望值：
	$f_{e}=\frac{RT}{n}\frac{CT}{n}xn=\frac{RTxCT}{n}$

式中,
**$f_{e}$** 为给定单元中的频数期望值;
$RT$为给定单元所在行的合计;
$CT$为给定单元所在列的合计;
$n$为观察值的总个数,即样本量。

计算结果如下表所示。

| 行  | 列  | $f_{o}$ | $f_{e}$ | $(f_{o}-f_{e})$ | $(f_{o}-f_{e})^{2}$ | $\frac{{(f_{o}-f_{e})}^2}{f_{e}}$ |
| --- | --- | ------- | ------- | --------------- | ------------------- | --------------------------------- |
| 1   | 1   | 52      | 45.36   | 6.64            | 44.09               | 0.97                              |
| 1   | 2   | 64      | 52.64   | 11.36           | 129.05              | 2.45                              |
| 1   | 3   | 24      | 42.00   | -18             | 324                 | 7.71                              |
| 2   | 1   | 60      | 55.40   | 4.60            | 21.16               | 0.38                              |
| 2   | 2   | 59      | 64。30  | -5.3            | 28.09               | 0.44                              |
| 2   | 3   | 52      | 51.30   | 0.7             | 0.49                | 0.01                              |
| 3   | 1   | 50      | 61.24   | -11.24          | 126.34              | 2.06                              |
| 3   | 2   | 65      | 71.06   | -6.06           | 36.72               | 0.52                              |
| 3   | 3   | 74      | 56.70   | 17.30           | 299.29              | 5.28                              |
|     |     |         |         |                 |                     | 19.82                             |
|     |     |         |         |                 |                     |  $χ^{2}=\sum{\frac{{(f_{o}-f_{e})}^2}{f_{e}}}=19.82$                                 |


$χ^{2}$的自由度$=(R-1)(C-1)=4$
令$α=0.05$,查表知:$χ^{2}_{0.05}(4)=9.488$。
由于$χ^{2}>χ^{2}_{0.05}(4)$故拒绝$H_{0}$,接受$H_{1}$,即地区和原料等级之间存在依赖关系,原料的质量受地区的影响。


★用SPSS进行列联分析的独立性检验的操作步骤
- 第1步：在SPSS数据编辑窗口中定义变量“生产地"、"质量”和“数量”，“质量”变量的取值有三个：1,2和3，其中，取值“1”表示一级，"2”表示二级，“3”表示三级。
- 第2步：选择【数据】下拉菜单，并选择【加权个案】选项进入主对话框。在主对话框中选择【加权个案】，将变量“数量”选入【频率变量】。
- 第3步：选择【分析】下拉菜单，再选择【描述统计】下拉菜单，最后选择【交叉表】选项进入主对话框。在主对话框中将“生产地”选入【行】，“质量”选入【列】。
- 第4步：在【统计量】下选择【卡方】。点击【单元格】。在【计数】下选择【观察值】和【期望值】。在【百分比】下选择【行】、【列】和【总计】。在【残差】下选择【未标准化】和【标准化】。点击【继续】。点击【确定】。
输出结果如下：

![[Pasted image 20230916213332.png|500]]

![[Pasted image 20230916213417.png|500]]


![[Pasted image 20230916213439.png]]

从上表可以看出,卡方值为19.822,相伴概率为0.001,故应拒绝原假设,认为原料的质量受地区的影响。

最后剖析一下$χ^{2}$检验中自由度计算的原理。
如前所述，自由度是可以自由取值的数据的个数，采用自由度=（行数一1）（列数-1）=(R-1)(C-1)公式计算。这样做
的原因可以通过以下例子说明。

假如现在我们有一个3×4列联表，如下表所示：

|     | C1  | C2  | C3  | C4  | 合计     |
| --- | --- | --- | --- | --- | -------- |
| R1  | ✓   | ✓   | ✓   | *   | $RT_{1}$ |
| R2  | ✓   | ✓   | ✓   | *   |      $RT_{2}$    |
| R3  | *   | *   | *   |  0   |      $RT_{3}$    |
|合计    |  $CT_{1}$   |  $CT_{2}$   |   $CT_{3}$  |   $CT_{4}$  |          |


注：√表示可以自由取值的数据。
*和0表示不能自由取值的数据。
由表9-6可知，RT1，RT2和RT分别表示行的合计，CT1,CT2,CT和CT4分
别表示列的合计。
首先考察列联表中的第一行,在行合计RT1已经确定的情况下,这一行可以自由取
值的数据只有3个（这里假定取前3个），用/表示，最后一个无法自由取值，用*表示。
类似地，在第二行，在行合计RT2已经确定的情况下，这一行可以自由取值的数据也只
有3个,因此第4个不能自由取值的数据也用*表示。在第三行,第一个数据(R3,C1)
不能自由取值，因为在列合计CT:已经确定的情况下，第一列的前两个数据已经自由取
值。同理,第三行中的第二个和第三个数据也不能自由取值,因此这一行的前三个数据均
用*表示。第三行的第四个数据也不能自由取值,用0表示,因为不论从行或列来看,它
前面的数据均是无法自由取值的（意味着该值已经确定），在行、列合计确定的情况下，
这个值也就无法自由选取。
表9-6是一个3×4列联表，自由度为6，即
自由度=(R-1)(C-1)=(3-1)×(4-1)=6
9.4
列联表中的相关测量
前面讨论了利用2分布对两个分类变量之间的相关性进行统计检验。如果变量相互
独立，说明它们之间没有联系；反之，则认为它们之间存在联系。接下来的问题是，如果
变量之间存在联系，它们之间的相关程度有多大？这一节主要讨论这个问题。
对两个变量之间相关程度的测定，主要用相关系数表示。正如前面所言，列联表中的
变量通常是分类变量，它们所表现的是研究对象的不同品质类别。所以，可以把这种分类
数据之间的相关称为品质相关。经常用到的品质相关系数有以下几种。
9.4.1
相关系数
φ相关系数（φ correlation coefficient）是描述2×2列联表数据相关程度最常用的一
种相关系数。计算公式为：
4=√x2/n
(9.3)
式中，2是按式(9.1)计算出的2值；n为列联表中的总频数，也即样本量。说系数























## 分类数据分析的R语言实现
### 分类变量的列联表和独立性检验
本节将关注分类变量的频数表、列联表，以及相应的独立性检验。除了使用基本包里的 函数，我们还将使用epiDisplay包里的函数，并比较不同的输出结果。本节以数据框birthwt为例。

如果没有安装epiDisplay包，请先安装：
```r
 install.packages("epiDisplay")
 library(epiDisplay)
```
#### 生成频数表和列联表
##### 一维频数表
一维频数表是只按一个变量的不同分类的频数进行统计的表。函数table（）可用于生成简单的一维频数表。例如：

```r
mytable <- table(birthwt$low)

mytable
```
如果你没有将数据集birthwt中的分类变量low、race、smoke、ht和ui转换成因子，那么，输出结果将如下：
```
  0   1
130  59
```
> 其中0代表不吸烟，1代表吸烟。

如果不将分类变量转换成因子，那么我们在理解结果时会有一些阅读转换上的困难。所以需要转换成因子。

另外，为了熟练掌握R语言，在这里顺便插入一些用R语言进行描述性统计的内容，在这之后我们再开始学习分类数据分析的R语言实现之分类变量的列联表和独立性检验。

## 描述性统计的 R语言实现
在学习如何将数据导入R，以及如何将数据转换为需要的格式之后，接着可以了解数据可视化的基本方法，开始图形的探索。那么，接下来的工作通常是描述各变量的分布，并探索变量两两之间的关系，这就需要学习描述性统计分析和基本的统计推断了，接下来将向您介绍数值型变量的描述性统计分析。

为了便于阐述，下面将使用MASS包里面的数据集birthwt。

> birthwt是一个R语言中的数据集，它包含了关于新生儿体重的数据。这个数据集主要用于研究预测新生儿体重的因素，以及评估这些因素对新生儿低体重风险的影响。birthwt数据集由MASS包提供，该包是R语言中一个广泛使用的统计软件包。 

> birthwt数据集共有189行和10列，每一行代表一个新生儿。数据集中的10个变量分别是：
> - bw（新生儿体重，以克为单位）、
> - gestation（妊娠期长，以天为单位）、
> - parity（产次，表示母亲此前的分娩次数）、
> - age（母亲的年龄）、
> - height（母亲的身高，以英寸为单位）、
> - weight（母亲的体重，以磅为单位）、
> - smoke（是否吸烟，1代表吸烟，0代表不吸烟）、
> - ptl（早产次数，表示母亲此前的早产次数）、
> - ht（高血压，1代表有高血压，0代表没有高血压）、
> - ui（子宫内生长迟缓，1代表有子宫内生长迟缓，0代表没有子宫内生长迟缓）。 
> 
> 使用birthwt数据集可以进行各种统计分析，例如线性回归、逻辑回归、决策树等。

> 下面是一个示例，展示如何在R语言中使用birthwt数据集进行线性回归分析：

```r 
# 加载MASS包 
library(MASS) 

# 加载birthwt数据集 
data(birthwt) 

# 进行线性回归分析 
model <- lm(bw ~ gestation + parity + age + height + weight + smoke + ptl + ht + ui, data = birthwt) 

# 查看回归结果 
summary(model) 
``` 


>通过上述代码，我们可以对新生儿的体重进行线性回归分析。回归模型包括了妊娠期长、产次、年龄、身高、体重、吸烟情况、早产次数、高血压和子宫内生长迟缓等因素。使用`summary`函数可以查看回归结果，包括回归系数估计值、显著性水平以及R方值等。 

>birthwt数据集是一个用于研究新生儿体重与各种因素之间关系的常用数据集。它提供了一个实际问题的例子，可以帮助研究人员和学生更好地理解和应用统计分析方法。在R语言中使用MASS包里的birthwt数据集，可以进行多种分析，深入研究新生儿体重与各种因素之间的关系，并为实际医学、公共卫生等领域的决策提供有效的支持。

>除了birthwt数据集之外，MASS包还提供了多个其他数据集，用于统计分析和练习。
>下面是几个主要的数据集示例： 
>1. Boston数据集：这个数据集包含了1970年代波士顿地区的房价和相关因素的数据。它是一个用于回归分析的经典数据集，常用于探索房价与其他因素（如犯罪率、学生-教师比例、房屋年龄等）之间的关系。 
>2. NOAA数据集：这个数据集是美国国家海洋和大气管理局（NOAA）提供的气象数据集。它包含了来自不同气象站点的气象观测数据，例如气温、湿度、风速等。NOAA数据集被广泛用于气象和气候分析。 
>3. mvrnorm数据集：这个数据集生成了多元正态分布的随机样本。它用于模拟多元正态数据，进行统计方法的验证和演示。 
>4. Abbey数据集：这个数据集是一项心理学实验中收集的数据，用于研究观察者评价人物特质的方法。它包含了来自不同观察者针对一系列人物特质的评价数据。 
>
>以上只是MASS包中部分数据集的示例，还有其他一些数据集可以在包的文档中找到。这些数据集提供了广泛的实例，可以用于统计分析、练习和教学。通过使用MASS包中的这些数据集，用户可以更好地理解和应用统计方法，并针对不同实际问题进行探索和分析。
###### 因子转换(**非常重要的一步**)
在分析之前，先将数据集birthwt中的分类变量low、race、smoke、ht和ui转换成因子：

```r
library(MASS) # 加载MASS包 

data(birthwt) # 加载birthwt数据集 

str(birthwt) # 显示birthwt数据集的结构 

library(dplyr) # 加载dplyr包 

birthwt <- birthwt %>% # 对birthwt数据集应用一系列的数据转换 
	mutate( 
			low = factor(low, labels = c("no", "yes")), # 将'low'变量转换为因子，并使用标签'no'和'yes' 
			race = factor(race, labels = c("white", "black", "other")), # 将'race'变量转换为因子，并使用标签'white'、'black'和'other' 
			smoke = factor(smoke, labels = c("no", "yes")), # 将'smoke'变量转换为因子，并使用标签'no'和'yes' 
			ht = factor(ht, labels = c("no", "yes")), # 将'ht'变量转换为因子，并使用标签'no'和'yes' 
			ui = factor(ui, labels = c("no", "yes")) # 将'ui'变量转换为因子，并使用标签'no'和'yes' 
		) 
		
str(birthwt) # 显示更新后的birthwt数据集的结构 
```
---
> 这里介绍一下`mutate()`函数：


在R语言中，`mutate()`是`dplyr`包中的一个函数，用于在数据框中创建新的变量或修改现有变量的值。 
`mutate()`函数的基本语法是： 
```
mutate(.data, ..., .preserve = NULL) 
``` 
其中，`.data`是输入的数据框，`...`是要添加或修改的变量，`.preserve`用于保留原始数据框的属性。 `mutate()`函数可以在`...`中使用多个参数，每个参数定义一个新的变量或修改现有变量的值。这些参数以变量名和赋值运算符`=`的形式给出，例如：

```R
mutate(.data, new_variable = expression, existing_variable = expression) 
``` 

`expression`是要应用的计算表达式，可以使用已存在的变量、常数、函数等。 

下面是一些示例，说明了`mutate()`函数的用法： 
```r
library(dplyr) 

# 创建新的变量 
iris_new <- iris %>% 
	mutate(petal_ratio = Petal.Width / Petal.Length)

# 修改现有变量的值 
iris_modified <- iris %>% 
	mutate(Sepal.Length = ifelse(Sepal.Length > 5, 5, Sepal.Length)) 

# 添加多个新的变量 
iris_new_variables <- iris %>% 
	mutate( 
		petal_ratio = Petal.Width / Petal.Length,
		sepal_ratio = Sepal.Width / Sepal.Length 
	) 
``` 

---

上面代码的输出结果还没说呢，结果如下：
```r
library(MASS) # 加载MASS包 
data(birthwt) # 加载birthwt数据集 
str(birthwt) # 显示birthwt数据集的结构 
r$> str(birthwt)
'data.frame':   189 obs. of  10 variables:
 $ low  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ age  : int  19 33 20 21 18 21 22 17 29 26 ...
 $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...
 $ race : int  2 3 1 1 1 3 1 3 1 1 ...
 $ smoke: int  0 0 1 1 1 0 0 0 1 1 ...
 $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ ht   : int  0 0 0 0 0 0 0 0 0 0 ...
 $ ui   : int  1 0 0 1 1 0 0 0 0 0 ...
 $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...
 $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...
library(dplyr) # 加载dplyr包 
birthwt <- birthwt %>% # 对birthwt数据集应用一系列的数据转换 
	mutate( 
			low = factor(low, labels = c("no", "yes")), # 将'low'变量转换为因子，并使用标签'no'和'yes' 
			race = factor(race, labels = c("white", "black", "other")), # 将'race'变量转换为因子，并使用标签'white'、'black'和'other' 
			smoke = factor(smoke, labels = c("no", "yes")), # 将'smoke'变量转换为因子，并使用标签'no'和'yes' 
			ht = factor(ht, labels = c("no", "yes")), # 将'ht'变量转换为因子，并使用标签'no'和'yes' 
			ui = factor(ui, labels = c("no", "yes")) # 将'ui'变量转换为因子，并使用标签'no'和'yes' 
		) 
str(birthwt) # 显示更新后的birthwt数据集的结构 
r$> str(birthwt)
'data.frame':   189 obs. of  10 variables:
 $ low  : Factor w/ 2 levels "no","yes": 1 1 1 1 1 1 1 1 1 1 ...
 $ age  : int  19 33 20 21 18 21 22 17 29 26 ...
 $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...
 $ race : Factor w/ 3 levels "white","black",..: 2 3 1 1 1 3 1 3 1 1 ...
 $ smoke: Factor w/ 2 levels "no","yes": 1 1 2 2 2 1 1 1 2 2 ...        
 $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ ht   : Factor w/ 2 levels "no","yes": 1 1 1 1 1 1 1 1 1 1 ...
 $ ui   : Factor w/ 2 levels "no","yes": 2 1 1 2 2 1 1 1 1 1 ...
 $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...
 $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...
```

你可以很明显地看出转换前后的区别。
##### 快速探索数据集
###### 函数`summary()`
获取数据框里的每个变量的常用统计量是一种快速探索数据集的方法，这可以通过下面的一个命令实现：
```r
summary(birthwt)
```

结果如下：
```r
r$> summary(birthwt)
  low           age             lwt           race    smoke          ptl           ht        ui           ftv              bwt      
 no :130   Min.   :14.00   Min.   : 80.0   white:96   no :115   Min.   :0.0000   no :177   no :161   Min.   :0.0000   Min.   : 709  
 yes: 59   1st Qu.:19.00   1st Qu.:110.0   black:26   yes: 74   1st Qu.:0.0000   yes: 12   yes: 28   1st Qu.:0.0000   1st Qu.:2414  
           Median :23.00   Median :121.0   other:67             Median :0.0000                       Median :0.0000   Median :2977  
           Mean   :23.24   Mean   :129.8                        Mean   :0.1958                       Mean   :0.7937   Mean   :2945  
           3rd Qu.:26.00   3rd Qu.:140.0                        3rd Qu.:0.0000                       3rd Qu.:1.0000   3rd Qu.:3487  
           Max.   :45.00   Max.   :250.0                        Max.   :3.0000                       Max.   :6.0000   Max.   :4990  
```

函数`summary()`可以对每一个变量进行汇总统计。
- 对于数值型变量，如`age` 、`lwt`、`pit`、`ftv` 和  `bwt` ，函数`summary()`给出四分位数、中位数、均值、上四分位数和最大值
- 对于分类变量，如`low`、`race`、`smoke`、`ht`、`ui`，给出的则是频数表。
###### 函数`summ()`
`epiDisplay`包的函数`summ()`作用于数据框可以得到另一种格式的汇总输出，它将变量按行排列，把最小值和最大值放在最后两列以方便查看数据的全距：
```r
library(epiDisplay)

summ(birthwt)
```
结果如下：
```r
r$> summ(birthwt)

No. of observations = 189

   Var. name obs. mean    median  s.d.   min.   max.  
1  low       189  1.312   1       0.465  1      2     
2  age       189  23.24   23      5.3    14     45    
3  lwt       189  129.81  121     30.58  80     250   
4  race      189  1.847   1       0.918  1      3
5  smoke     189  1.392   1       0.489  1      2     
6  ptl       189  0.2     0       0.49   0      3
7  ht        189  1.063   1       0.244  1      2
8  ui        189  1.148   1       0.356  1      2
9  ftv       189  0.79    0       1.06   0      6
10 bwt       189  2944.59 2977    729.21 709    4990
```

> 需要注意的是，对于因子型变量，函数`summ()`把变量的各个水平当作数值计算各个统计量（总数、平均值、中位数、标准差、最小值、最大值）。

### 数值型变量的描述性统计分析
> 钱是英雄胆，金是男儿腰。
> 一睁眼就需要钱的世界，只要你穷什么都克你，
> 经济到位，全是阳春三月；
> 穷困潦倒，全是寒冬腊月。
> 红尘求财不求心，风风雨雨度春秋。
> 男儿身负千斤担终有拨云见日头。

接下来才是正题
本节将讨论数值型变量的集中趋势、离散趋势和分布形状等。这里我们关注3个连续型变量：年龄（`age`）、母亲怀孕前体重（`lwt`）和婴儿出生时体重（`bwt`）。

接下来，先计算这3个变量的描述性统计量，然后按照母亲吸烟情况（`smoke`）分组考查描述性统计量。这里`smoke`是一个二分类变量，我们在把它转换成因子变量时已经为其两个水平定义了标签：”`no`“和”`yes`“。
#### 计算这3个变量的描述性统计量

##### 方法1：函数`summary()`
```r
cont.vars <- dplyr::select(birthwt, age, lwt, bwt)
```

可用函数`summary()`查看：
```r
summary(cont.vars)

r$> summary(cont.vars)
      age             lwt             bwt
 Min.   :14.00   Min.   : 80.0   Min.   : 709
 1st Qu.:19.00   1st Qu.:110.0   1st Qu.:2414
 Median :23.00   Median :121.0   Median :2977
 Mean   :23.24   Mean   :129.8   Mean   :2945
 3rd Qu.:26.00   3rd Qu.:140.0   3rd Qu.:3487
 Max.   :45.00   Max.   :250.0   Max.   :4990
```

##### 方法2：逐个计算
除了上面提到的函数`summary()`，R中还有很多用于计算特定统计量的函数，如下表：

|函数|描述|
|---|---|
|length(x)|求x中元素的个数|
|mean(x)|求x的算数平均值|
|median(x)|求x的中位数|
|var(x)|求x的样本方差|
|sd(x)|求x的样本标准差|
|range(x)|求x的全距|
|mix(x)|求x的最小值|
|max(x)|求x的最大值|
|quantile(x)|求x的分位数|
|sum(x)|求x中所有元素的和|
|scale(x)|将x标准化|

在这里计算age的样本量、样本均值和样本标准差：
```r
length(cont.vars$age)

mean(cont.vars$age)

sd(cont.vars$age)

```

结果如下：

```r
r$> length(cont.vars$age)
    mean(cont.vars$age)
    sd(cont.vars$age)
[1] 189    
[1] 23.2381
[1] 5.298678

```

##### 方法3：函数`sapply()`
我们还可以用函数`sapply()`同时计算数据框中多个变量的指定统计量。例如，计算数据框`cont.vars`中各个变量的样本标准差：
```r
sapply(cont.vars, sd)
```

结果如下：
```r
r$> sapply(cont.vars, sd)
       age        lwt        bwt 
  5.298678  30.579380 729.214295 
```

##### 方法4：函数`describe()`
基本包中没有提供计算偏度和峰度的函数，我们可以根据公式自己计算，也可以调用其他包里的函数计算，例如`Hmisc`包、`psych`包和`pstecs`包等。这些包提供了种类繁多的计算统计量的函数，这几个包在首次使用前需要先安装。

下面以`psych`包为例进行说明。

`psych`包被广泛用于计量心理学，在后面的因子分析部分，我们还将用到这个包。

> 同是风华正茂，岂可甘拜下风？
> 越是穷途末路，越要势如破竹。
> 逆风景色，不过尔尔。
> 无人扶我青云志，我自踏雪至山巅。

`psych`包里的函数`describe()`可以计算变量忽略缺失值后的样本量、均值、标准差、中位数、截尾均值、绝对中位差、最小值、最大值、全距、偏度、峰度和标准误等。
例如：
```r
#install.packages("psych")
library(psych)

describe(cont.vars)
```
结果如下：
```r
r$> describe(cont.vars)
    vars   n    mean     sd median trimmed    mad min  max range  skew kurtosis    se
age    1 189   23.24   5.30     23   22.90   5.93  14   45    31  0.71     0.53  0.39
lwt    2 189  129.81  30.58    121  126.07  20.76  80  250   170  1.38     2.25  2.22
bwt    3 189 2944.59 729.21   2977 2961.76 834.70 709 4990  4281 -0.21    -0.14 53.04
```

#### 按照母亲吸烟情况（`smoke`）分组考查描述性统计量
> 人生不如意十之八九，可与人言无二三。
> 熟人不知我近况，新人不知我过往。
> 近况不与熟人说，过往不与新人讲。
> 悲喜自度，他人难悟。
> 这世上有种东西叫运气，有了它，没什么不可能的，愿你好运来临。
##### 方法1：函数`aggregate()`
在很多时候我们还想计算某个分类变量各个类别下的统计量。在R中完成这个任务有多种方式，下面从基本包的函数`aggregate()`和`tapply()`开始介绍：
```r
aggregate(cont.vars, by = list(smoke = birthwt$smoke), mean)

aggregate(cont.vars, by = list(smoke = birthwt$smoke), sd)
```
结果如下：
```r
r$> aggregate(cont.vars, by = list(smoke = birthwt$smoke), mean)
    aggregate(cont.vars, by = list(smoke = birthwt$smoke), sd)
  smoke      age      lwt      bwt
1    no 23.42609 130.8957 3055.696
2   yes 22.94595 128.1351 2771.919
  smoke      age      lwt      bwt
1    no 5.467706 28.42700 752.6566
2   yes 5.047424 33.78673 659.6349
```

函数`aggregate()`中的参数`by`必须设为`list`。如果直接使用`list(birthwt$smoke)`，则上面分组列的名称将会是“Group.1”而不是“smoke”。
```r
aggregate(cont.vars, list(birthwt$smoke), mean)

aggregate(cont.vars, list(birthwt$smoke), sd)
```
结果如下：
```r
r$> aggregate(cont.vars, list(birthwt$smoke), mean)
    aggregate(cont.vars, list(birthwt$smoke), sd)
  Group.1      age      lwt      bwt
1      no 23.42609 130.8957 3055.696
2     yes 22.94595 128.1351 2771.919
  Group.1      age      lwt      bwt
1      no 5.467706 28.42700 752.6566
2     yes 5.047424 33.78673 659.6349
```
##### 方法2：在函数`aggregate()`的list里面设置多个分类变量
```r
aggregate(cont.vars,

          by = list(smoke = birthwt$smoke, race = birthwt$race),

          mean)
```
结果如下：
```r
    aggregate(cont.vars, 
              by = list(smoke = birthwt$smoke, race = birthwt$race), 
              mean)
  smoke  race      age      lwt      bwt
1    no white 26.02273 138.8409 3428.750
2   yes white 22.82692 126.3077 2826.846
3    no black 19.93750 149.4375 2854.500
4   yes black 24.10000 142.6000 2504.000
5    no other 22.36364 119.1455 2815.782
6   yes other 22.50000 124.0000 2757.167
```

这里的分类变量有2个，其中`smoke`有2个类别，`race`有3个类别，上面的命令按照这两个变量各个类别的所有组合（共六祖）计算均值。

##### 方法3：函数`tapply()`
函数`tapply()`可以实现类似的功能，不同的是它的第一个参数必须是一个变量，第二个参数名是`INDEX`，而不是`by`。例如，计算变量`bwt`在母亲不同吸烟情况下的均值，可以输入：

> **以后的代码将命令与结果合二为一显示**
```r
r$> tapply(birthwt$bwt, INDEX = birthwt$smoke, mean)
      no      yes
3055.696 2771.919
```
> **以后的代码将命令与结果合二为一显示**

##### 方法4：函数`summ()`
`epiDisplay`包里的函数`summ()`也可以实现类似的功能，不同的是该函数里的统计量是固定的，而且函数的输出包含一个按照分类变量绘制的有序点图：
```r
library(epiDisplay)

summ(birthwt$bwt, by = birthwt$smoke)
```
结果如下：
```r
r$> summ(birthwt$bwt, by = birthwt$smoke)
For birthwt$smoke = no
 obs. mean     median  s.d.    min.   max.  
 115  3055.696 3100    752.657 1021   4990  

For birthwt$smoke = yes
 obs. mean     median  s.d.    min.   max.  
 74   2771.919 2775.5  659.635 709    4238  
```

 ![[Pasted image 20230828203259.png]]
*婴儿出生体重在母亲不同吸烟情况下的有序点图*

用函数`summ()`输出的有序点图探索数值型变量的分布尤其是数据的密集趋势和异常值非常方便。

##### 方法5：函数`describeBy()`
`psych`包里的函数`describeBy()`也可以分组计算与函数`describe()`相同的统计量，例如：
```r
r$> describeBy(cont.vars, birthwt$smoke)

 Descriptive statistics by group 
group: no
    vars   n    mean     sd median trimmed    mad  min  max range  skew kurtosis    se
age    1 115   23.43   5.47     23   23.09   4.45   14   45    31  0.77     1.00  0.51
lwt    2 115  130.90  28.43    124  127.62  20.76   85  241   156  1.30     2.00  2.65
bwt    3 115 3055.70 752.66   3100 3086.14 816.91 1021 4990  3969 -0.28    -0.32 70.19
----------------------------------------------------------------------------------------------------------------------------------------- 
group: yes
    vars  n    mean     sd median trimmed    mad min  max range  skew kurtosis    se
age    1 74   22.95   5.05   22.0   22.60   5.93  14   35    21  0.55    -0.73  0.59
lwt    2 74  128.14  33.79  120.0  123.58  22.24  80  250   170  1.45     2.22  3.93
bwt    3 74 2771.92 659.63 2775.5 2782.55 630.10 709 4238  3529 -0.28     0.23 76.68
```

函数`describeBy()`虽然方便，但它不能指定任意函数，所以扩展性较差。实际上，`dplyr`包里的函数`group_by()`和`summarize()`就能非常灵活地计算分组统计量。例如：
```r
library(dplyr)

birthwt %>%

  group_by(smoke) %>%

  summarise(Mean.bwt = mean(bwt), Sd.bwt = sd(bwt))
```
结果如下：
```
r$> birthwt %>%
      group_by(smoke) %>% 
      summarise(Mean.bwt = mean(bwt), Sd.bwt = sd(bwt))
# A tibble: 2 x 3
  smoke Mean.bwt Sd.bwt
  <fct>    <dbl>  <dbl>
1 no       3056.   753.
2 yes      2772.   660.
```

> 数据分析者可以选择自己最习惯的方式计算和展示描述性统计量。赵军老师认为最后一种方式思路最为清晰，结果最为简洁。

## 分类数据分析的R语言实现
### 分类变量的列联表
本节将关注分类变量的频数表、列联表，以及相应的独立性检验。除了使用基本包里的 函数，我们还将使用`epiDisplay`包里的函数，并比较不同的输出结果。本节以数据框`birthwt`为例。

#### 生成频数表和列联表
##### 一维频数表
###### 方法1：函数`table（）`
一维频数表是只按一个变量的不同分类的频数进行统计的表。函数`table（）`可用于生成简单的一维频数表。例如：

```r
mytable <- table(birthwt$low)

mytable
```
结果如下
```r
 no yes 
130  59 
```

上面是频数表展示的是绝对数。通常来说，人们更感兴趣的是相对数或百分比。
###### 方法2：函数`prop.table()`
函数`prop.table()`可以将上面转换成百分比的形式：
```r
r$> prop.table(mytable)

       no       yes
0.6878307 0.3121693

r$> round(prop.table(mytable)*100, 1)

  no  yes 
68.8 31.2 
```

为了使输出更简洁，上面使用函数`round()`将结果只保留了一位小数。结果表明，有近三分之一的新生儿体重偏低。
###### 方法3：函数`tabl()`
`epiDisplay`包里的函数`tabl()`不仅可以给出一维频数表，还能给出百分比和累计百分比。与此同时，它还输出一个非常实用的频数分布条形图：
```r
r$> library(epiDisplay)

r$> tab1(birthwt$low)
birthwt$low :
        Frequency Percent Cum. percent
no            130    68.8         68.8
yes            59    31.2        100.0
  Total       189   100.0        100.0
```

![[Pasted image 20230828210659.png]]
*婴儿出生体重频数分布条形图*

如果想只显示频数表而不显示条形图，可以将函数`tabl()`中的参数`graph`设置为`FALSE`，此外，还可以设置该函数中的很多参数以改变输出样式，参数的具体意义可以查阅其帮助文档。

>在R语言中，`epiDisplay`包是用于展示和分析流行病学和临床研究数据的包。`tabl()`函数是该包中的一个函数，用于生成数据的交叉表和列联表。 


>具体的语法是： `tabl(formula, data, col.vars, row.vars, total, showMissing = FALSE, showRowPercentage = TRUE, showColumnPercentage = TRUE, showTotalPercentage = TRUE, ...)`。 


>参数的具体意义如下： 

- `formula`: 用于描述所需交叉表的公式，一般为因变量和自变量之间的关系。 
- `data`: 数据框，包含了所需的变量。 
- `col.vars`: 列部分的变量名称或向量。 
- `row.vars`: 行部分的变量名称或向量。 
- `total`: 逻辑值，表示是否在交叉表中显示总计。 
- `showMissing`: 逻辑值，表示是否在交叉表中显示缺失值。 
- `showRowPercentage`: 逻辑值，表示是否显示行百分比。 
- `showColumnPercentage`: 逻辑值，表示是否显示列百分比。 
- `showTotalPercentage`: 逻辑值，表示是否显示总计百分比。 
- `...`: 其他参数，用于传递给底层函数。

> `tabl()`函数的作用是根据给定的变量，生成一个交叉表或列联表，展示变量之间的关系。可以通过调整参数来控制所显示的内容，例如包含行和列百分比、总计百分比以及缺失值的显示等。

上面我们将函数`tabl()`运用于分类变量，实际上，该函数同样可以运用于数值型变量以探索数据的缺失值和异常值。例如：
```r
r$> tab1(birthwt$age)
birthwt$age :
        Frequency Percent Cum. percent
14              3     1.6          1.6
15              3     1.6          3.2
16              7     3.7          6.9
17             12     6.3         13.2
18             10     5.3         18.5
19             16     8.5         27.0
20             18     9.5         36.5
21             12     6.3         42.9
22             13     6.9         49.7
23             13     6.9         56.6
24             13     6.9         63.5
25             15     7.9         71.4
26              8     4.2         75.7
27              3     1.6         77.2
28              9     4.8         82.0
29              7     3.7         85.7
30              7     3.7         89.4
31              5     2.6         92.1
32              6     3.2         95.2
33              3     1.6         96.8
34              1     0.5         97.4
35              2     1.1         98.4
36              2     1.1         99.5
45              1     0.5        100.0
  Total       189   100.0        100.0
```

![[Pasted image 20230828212101.png]]

结果表明，年龄最小值为14，最大值为45，没有缺失值和异常值。

##### 二维列联表
二维列联表是按两个变量交叉分类进行统计的频数表。
###### 方法1：
对于二维列联表，函数`table()`同样适用。例如：
```r
r$> mytable <- table(birthwt$smoke, birthwt$low)
    mytable

      no yes
  no  86  29
  yes 44  30
```

因为变量`smoke`和变量`low`都是二分类变量，所以我们得到一个2x2的四格表。
###### 方法2：函数`addmargins()`
对于这个2x2的四格表，我们可以使用函数`addmargins()`生成边际频数。
```r
r$> addmargins(mytable)

       no yes Sum
  no   86  29 115
  yes  44  30  74
  Sum 130  59 189
```

###### 方法3：函数`prop.table()`
我们还可以使用函数`prop.table()`将上面的绝对数转换成相对数，即生成频率表。
```r
r$> prop.table(mytable, margin = 1)

             no       yes
  no  0.7478261 0.2521739
  yes 0.5945946 0.4054054

r$> prop.table(mytable, margin = 2)

             no       yes
  no  0.6615385 0.4915254
  yes 0.3384615 0.5084746

```

函数`prop.table()`中的参数`margin`用于设置按行或按列求比例。

###### 方法4：函数`tabpct()`
`epiDisplay`包里的函数`tabpct()`可以一次性得到上面的结果，同时还输出一个马赛克图：
```r
r$> tabpct(birthwt$smoke, birthwt$low)

Original table
             birthwt$low      
birthwt$smoke   no  yes  Total
        no      86   29    115
        yes     44   30     74
        Total  130   59    189

Row percent
             birthwt$low
birthwt$smoke      no     yes  Total
          no       86      29    115
               (74.8)  (25.2)  (100)
          yes      44      30     74
               (59.5)  (40.5)  (100)

Column percent
             birthwt$low
birthwt$smoke   no       %  yes       %
        no      86  (66.2)   29  (49.2)
        yes     44  (33.8)   30  (50.8)
        Total  130   (100)   59   (100)
```

![[Pasted image 20230828213909.png]]
*母亲吸烟情况与婴儿低出生体重的马赛克图*

> 上述结果表明，新生儿低体重的比例在母亲吸烟情况中较高

##### 多维列联表
###### 方法1：函数`table()`、`prop.table()`和`addmargins()`
多维列联表在实际数据分析中较少用到，上面针对二维列联表的函数`table()`、`prop.table()`和`addmargins()`等都可以很自然地推广到多维列联表中。
```r
#多维列联表
#library(MASS)
#data(birthwt)
#未进行因子转换

r$> mytable <- table(birthwt$smoke, birthwt$low, birthwt$race)
    margin.table(mytable, 3)

 1  2  3 
96 26 67 

r$> margin.table(mytable, c(1, 3))

     1  2  3
  0 44 16 55
  1 52 10 12

r$> addmargins(mytable)
, ,  = 1


        0   1 Sum
  0    40   4  44
  1    33  19  52
  Sum  73  23  96

, ,  = 2


        0   1 Sum
  0    11   5  16
  1     4   6  10
  Sum  15  11  26

, ,  = 3


        0   1 Sum
  0    35  20  55
  1     7   5  12
  Sum  42  25  67

, ,  = Sum


        0   1 Sum
  0    86  29 115
  1    44  30  74
  Sum 130  59 189


r$> prop.table(mytable,c(1,3))
, ,  = 1


             0          1
  0 0.90909091 0.09090909
  1 0.63461538 0.36538462

, ,  = 2


             0          1
  0 0.68750000 0.31250000
  1 0.40000000 0.60000000

, ,  = 3


             0          1
  0 0.63636364 0.36363636
  1 0.58333333 0.41666667
```

```r
#library(MASS)
#data(birthwt)
#str(birthwt)
#library(dplyr)
#birthwt <- birthwt %>%
  #mutate(low = factor(low, labels = c("no", "yes")),
         #race = factor(race, labels = c("white", "black", "other")),
         #smoke = factor(smoke, labels = c("no", "yes")),
         #ht = factor(ht, labels = c("no", "yes")),
         #ui = factor(ui, labels = c("no", "yes")))
#str(birthwt)
#以上步骤是进行因子转换的过程

r$> mytable <- table(birthwt$smoke, birthwt$low, birthwt$race)
    margin.table(mytable, 3)

white black other
   96    26    67

r$> margin.table(mytable, c(1, 3))

      white black other
  no     44    16    55
  yes    52    10    12

r$> addmargins(mytable)
, ,  = white     


       no yes Sum
  no   40   4  44
  yes  33  19  52
  Sum  73  23  96

, ,  = black


       no yes Sum
  no   11   5  16
  yes   4   6  10
  Sum  15  11  26

, ,  = other


       no yes Sum
  no   35  20  55
  yes   7   5  12
  Sum  42  25  67

, ,  = Sum


       no yes Sum
  no   86  29 115
  yes  44  30  74
  Sum 130  59 189


r$> prop.table(mytable,c(1,3))
, ,  = white


              no        yes
  no  0.90909091 0.09090909
  yes 0.63461538 0.36538462

, ,  = black


              no        yes
  no  0.68750000 0.31250000
  yes 0.40000000 0.60000000

, ,  = other


              no        yes
  no  0.63636364 0.36363636
  yes 0.58333333 0.41666667
```
###### 方法2：函数`ftable()`
此外，函数`ftable()`可以将三维列联表转换为一种紧凑的格式输出：
```r
r$> ftable(mytable)
         white black other

no  no      40    11    35
    yes      4     5    20
yes no      33     4     7
    yes     19     6     5
```
### 分类变量的独立性检验（$χ^{2}$检验）
前面只是了解一下列联表，接下来才真正进入统计的世界。

列联表可以展示分类变量各个组合下的频数或比例，不过我们通常还会对这些分类变量之间是否关联感兴趣。此时，就需要独立性检验了。

#### $χ^{2}$独立性检验
对于一般的列联表，可以使用函数`chisq.test()`进行检验。例如，想要知道母亲吸烟情况和新生儿低体重之间的关系是否独立，可以使用下面的命令:
```r
r$> mytable <- table(birthwt$smoke, birthwt$low)
    mytable

      no yes
  no  86  29
  yes 44  30

r$> chisq.test(mytable)

        Pearson's Chi-squared test with Yates' continuity correction

data:  mytable
X-squared = 4.2359, df = 1, p-value = 0.03958
```

函数`chisq.test()`的参数`correct`用于设置是否进行连续性校正，默认为`TURE`，故在输出中有说明`"Pearson's Chi-squared test with Yates' continuity correction"`。对于频数表中每个单元格的期望都比较大（大于5）的大样本，可以将这个参数设置为`FALSE`，即不进行连续性校正。

函数`chisq.test()`的输出中包含了期望频数表，我们可以通过下面的命令查看：
```r
r$> chisq.test(mytable)$expected

            no      yes
  no  79.10053 35.89947
  yes 50.89947 23.10053
```

结果表明，每个单元格的期望都比较大，所以可以尝试将参数`correct`设置为`FALSE`：
```r
r$> chisq.test(mytable, correct = FALSE)

        Pearson's Chi-squared test

data:  mytable
X-squared = 4.9237, df = 1, p-value = 0.02649
```

从上面的输出可以看出，不论是否进行连续性校正，母亲吸烟的情况与新生儿低体重都存在显著的关联（p<0.05）。
#### Fisher精确概率检验
如果观察的总记录数n小于40，或者频数表里的某个期望频数很小（小于1），则需要使用Fisher精确概率检验。函数`fisher.test()`可用于执行该检验。即使频率期望数都较大，仍然可以尝试使用Fisher精确概率检验，例如：
```r
r$> fisher.test(mytable)

        Fisher's Exact Test for Count Data

data:  mytable
p-value = 0.03618
alternative hypothesis: true odds ratio is not equal to 1
95 percent confidence interval:
 1.028780 3.964904
sample estimates: 
odds ratio        
  2.014137
```

检验结果与上面的一致。

> 与很多软件不同，函数`fisher.test()`不仅可以运用于四格表，还可以运用于行列数大于2的列联表。

#### 相对危险度与优势比
上面对列联表的检验关注的是行变量各水平的关联程度，如果想知道行变量某一水平和列变量某一水平相对于基础水平的关联程度，就需要用相对危险度（Relative Risk,RR）和优势比（Odds Ratio,OR）了。

> 下面对相对危险度（Relative Risk,RR）和优势比（Odds Ratio,OR）进行解释。

设试验组人群的发病率为$P_{1}$，对照组人群的发病率为$P_{2}$，则$RR=P_{1}/P_{2}$，即暴露组人群的发病率与非暴露组人群的发病率之比。

RR用于反映暴露因素与结局事件相关联的程度，其取值范围为０到无穷大。
- 数值为１时，表明暴露因素与结局事件无关联
- 数值小于１时，表明暴露因素导致结局事件的发生概率降低
- 数值大于１时，表明暴露因素导致结局事件的发生概率增加

RR的计算要求知道各组的发病率，由于在横断面研究或回顾性研究中，很难得到人群的发病率的估计值（事实上，临床医生得不到人群的发病率，因为人群是是一个很大的概念，几万人甚至十几万人的调查才能得出人群的发病率，这个庞大的数据仅靠医院的病人难以测出某病在几万人甚至十几万人中的发病率，但是疾控能得到人群中的发病率），因此也就无法估计RR，此时**我们往往使用OR代替RR**。

OR是指暴露组中病例与非病例人数的比值除以非暴露组中病例与非病例人数的比值。
设患病人数的比例为P，则P/(1-P)称为患病的优势（Odds）或比值。而OR就是暴露组的Odds与非暴露组的Odds之比，即
$$OR=\dfrac{暴露组患病比例/(1-暴露组患病比例)}{非暴露组患病比例/(1-非暴露组患病比例)}$$

与RR一样，OR的取值范围也为0到无穷大。
- 如果OR值大于1，说明该暴露因素更容易导致结果事件发生，或者说该因素是一个危险因素
- 如果OR值小于1，则说明该暴露因素更不容易导致结果事件发生，或者说该因素是一个保护因素

`epiDisplay`包里的函数`cs()`和`cc()` 分别可以用于计算RR和OR，以及它们的置信区间。

需要说明的是，列联表中行变量和列变量的顺序不会影响独立性检验的结果，而函数`cs()`和`cc()` 的第一个参数`outcome`需要设为结果变量，这里是`low`（新生儿低体重）。

```r
r$> library(epiDisplay)
    cs(birthwt$low, birthwt$smoke)

          Exposure
Outcome    Non-exposed Exposed Total
  Negative 86          44      130  
  Positive 29          30      59   
  Total    115         74      189  

           Rne         Re      Rt
  Risk     0.25        0.41    0.31

                                         Estimate Lower95ci Upper95ci
 Risk difference (attributable risk)     0.15     0.01      0.28
 Risk ratio                              1.61     1.02      2.53
 Attr. frac. exp. -- (Re-Rne)/Re         0.38
 Attr. frac. pop. -- (Rt-Rne)/Rt*100 %   19.22
 Number needed to harm (NNH)             6.53     3.6       69.11
   or 1/(risk difference)
```


**函数`cs()`的输出结果还包括其他几个指标，如危险度（Risk difference）、归因危险度（attributable risk）和人群归因危险度（population attributable risk）等**

需要说明的是，上述计算只为介绍函数`cs()`的用法，并没有实际意义。因为本例的数据来自一项病例对照研究，无法得出各暴露组的发病率。所以，这里用函数`cc()`计算OR更为恰当。

函数`cc()`不仅给出了$χ^{2}$独立性检验的结果和Fisher精确概率检验的结果，还输出了一个优势比的变化图：

```r
r$> cc(birthwt$low, birthwt$smoke)

           birthwt$smoke 
birthwt$low  no yes Total
      no     86  44   130
      yes    29  30    59
      Total 115  74   189

OR =  2.02
95% CI =  1.08, 3.78
Chi-squared = 4.92, 1 d.f., P value = 0.026
Fisher's exact test (2-sided) P value = 0.036
```

![[Pasted image 20230829123002.png]]

函数`cs()`和`cc()` 里面都有一个参数`cctable`，用于输入列联表格式的数据。例如，使用下面的命令可以得到与上面相同的结果：
```r
r$> mytable <- table(birthwt$low, birthwt$smoke)
    cc(cctable = mytable)


         no yes Total
  no     86  44   130
  yes    29  30    59
  Total 115  74   189

OR =  2.02
95% CI =  1.08, 3.78
Chi-squared = 4.92, 1 d.f., P value = 0.026
Fisher's exact test (2-sided) P value = 0.036
```

#### Cochran-Mantel-Haensel$χ^{2}$检验
两个变量的关联有可能受到第三个变量的影响，因此我们有必要检验两个分类变量在调整（控制）第三个变量的情况下是否独立。Cochran-Mantel-Haensel$χ^{2}$检验常用于探索变量间的混杂因素。其**零假设是：两个分类变量在第三个变量的每一层都是条件独立的。**
##### 方法1：函数`mantelhan.test()`
函数`mantelhan.test()`可以用来进行检验。

下面的例子为分析在控制不同种族（白人、黑人和其他）条件下新生儿低体重与母亲吸烟情况是否独立。

```r
r$> mytable <- table(birthwt$low, birthwt$smoke, birthwt$race)
    mytable
, ,  = white


      no yes
  no  40  33
  yes  4  19

, ,  = black


      no yes
  no  11   4
  yes  5   6

, ,  = other


      no yes
  no  35   7
  yes 20   5

r$> mantelhaen.test(mytable)

        Mantel-Haenszel chi-squared test with continuity correction

data:  mytable
Mantel-Haenszel X-squared = 8.3779, df = 1, p-value = 0.003798     
alternative hypothesis: true common odds ratio is not equal to 1   
95 percent confidence interval:
 1.490740 6.389949
sample estimates:
common odds ratio
         3.086381
```

结果表明，新生儿低体重与母亲吸烟情况在调整种族条件的情况下依然不独立（p=0.003798）（不独立说明可能相关，但不一定是相关的哦）.
##### 方法2：`epiDisplay`包里的函数`mhor()`
`epiDisplay`包里的函数`mhor()`也可以完成上面的任务，且输出结果更丰富：

```r
r$> mhor(mhtable = mytable)

Stratified analysis by  Var3
               OR lower lim. upper lim. P value
Var3 white   5.66      1.657      25.14 0.00179
Var3 black   3.14      0.487      23.45 0.22797
Var3 other   1.25      0.273       5.28 0.75103
M-H combined 3.09      1.491       6.39 0.00215

M-H Chi2(1) = 9.41 , P value = 0.002
Homogeneity test, chi-squared 2 d.f. = 2.98 , P value = 0.225
```

![[Pasted image 20230829124812.png]]

**注意到上面的函数`mantelhan.test()`与`mhor()`的输出结果中$χ^{2}$值和p值略有不同，这是因为前者默认进行连续性校正（corract=TRUE），而后者不进行连续性校正**。

类似于函数`cc()`，函数`mhor()`里也可以直接输入原始变量（注意输入的顺序），得到的结果与上面相同：
```r
r$> mhor(birthwt$low, birthwt$smoke, birthwt$race)

Stratified analysis by  Var3
               OR lower lim. upper lim. P value
Var3 white   5.66      1.657      25.14 0.00179
Var3 black   3.14      0.487      23.45 0.22797
Var3 other   1.25      0.273       5.28 0.75103
M-H combined 3.09      1.491       6.39 0.00215

M-H Chi2(1) = 9.41 , P value = 0.002
Homogeneity test, chi-squared 2 d.f. = 2.98 , P value = 0.225
```

可以发现p>0.05，所以拒绝**零假设是：两个分类变量在第三个变量的每一层都是条件独立的。**

#### 配对列联表的$χ^{2}$检验
医学科研实践中经常遇到配对设计的计数资料，例如针对某一疾病的两种检验方法、针对某一疾病的两种诊断结果的比较。其特点是对每个研究对象分别用两种方法处理，然后观察处理方法的某两分类变量的计数结果。

对于这种数据，我们也可以整理成列联表的形式，但是不能用前述的$χ^{2}$独立性检验，需要进行Mcnemar检验。函数`mcnemar.test()`可以进行该检验，下面通过一个例子说明此函数的用法：

|<br>免疫荧光法|乳胶凝集法|
|---|---|---|
| |+|-|
|+|11|12|
|-|2|33|

根据上表中的数据建立矩阵，然后进行mcnemar检验：
```r
r$> my.matrix <- matrix(c(11, 2, 12, 33), nrow = 2)
    mcnemar.test(my.matrix)

        McNemar's Chi-squared test with continuity correction

data:  my.matrix
McNemar's chi-squared = 5.7857, df = 1, p-value = 0.01616 
```

结果表明，两种方法的检测结果的差异具有统计学意义（p=0.01616）,**免疫荧光法的阳性检测率较高**。

对于配对四格表，如果样本量较小（不一致的结果的总数小于40），则需要进行连续性校正。

函数`mcnemar.test()`里的参数`corract`的默认值为`TRUE`，所以这里不需要修改。需要说明的是，函数`mcnemar.test()`也适用于行列数大于2的列联表

例如3x3的列联表
```r
my.matrix <- matrix(c(11, 2, 12, 33,45,44,67,12,33), nrow = 3)
my.matrix
    mcnemar.test(my.matrix)
```

```r
r$> my.matrix <- matrix(c(11, 2, 12, 33,45,44,67,12,33), nrow = 3)

r$> my.matrix
     [,1] [,2] [,3]
[1,]   11   33   67
[2,]    2   45   12
[3,]   12   44   33

r$> mcnemar.test(my.matrix)

        McNemar's Chi-squared test

data:  my.matrix
McNemar's chi-squared = 84.034, df = 3, p-value < 2.2e-16
```

以上就是分类数据分析的R语言实现的全部内容，更多精彩内容，请阅读下一章节：方差分析。






























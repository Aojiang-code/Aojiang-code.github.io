下面是**第 8 章：基础特征**的详细学习笔记。
全章坚持你的技术约束：**DuckDB + CSV/Parquet + Python（pandas/Polars）+ Jupyter（VSCode）**，**不使用 SQL / Postgres**。示例均为**数据帧工作流**范式，可直接嵌入 Notebook 运行。

---

# 第8章 基础特征

> 目标：在\*\*特征窗 0–24h（以 `icustays.intime` 为锚）\*\*内构建稳定、可解释、零泄漏的基础特征层（人口学 + 就诊 + 合并症），输出到 `data/derived/features_basic_0_24h.parquet`，后续与实验室/生命体征等拼接形成完整特征集。

---

## 8.1 人口学：年龄（去标识规则下的计算）、性别

**原则**

* **时间偏移**下，跨患者绝对年份不可比，但**同一患者内相对时间**可靠。
* MIMIC-IV 的 `patients` 含 `anchor_age/anchor_year/anchor_year_group`。**近似年龄**可按：
  `age_at_event_year = anchor_age + year(event_time) - anchor_year`（>89 仍记为 91）。
* 性别来自 `patients.gender`（'M'/'F'）。建模时可做 **one-hot** 或二元编码。

**实现（Polars）**

```python
from pathlib import Path
import polars as pl

RAW = Path("data/raw"); DER = Path("data/derived"); DER.mkdir(parents=True, exist_ok=True)
PAT = RAW/"mimiciv_hosp/patients.csv.gz"
ICU = RAW/"mimiciv_icu/icustays.csv.gz"

pat = (
    pl.scan_csv(PAT)
      .select(["subject_id","gender","anchor_age","anchor_year"])
      .collect()
)

icu = (
    pl.scan_csv(ICU)
      .select(["subject_id","hadm_id","stay_id","intime","first_careunit"])
      .collect()
      # 提取事件年份（按年近似，满足去标识规则）
      .with_columns(pl.col("intime").dt.year().alias("intime_year"))
)

demo = (
    icu.join(pat, on="subject_id", how="left")
       .with_columns((
            pl.col("anchor_age") + pl.col("intime_year") - pl.col("anchor_year")
        ).clip_min(0).alias("age_at_icu"))
       # 高龄合并：>=90 统一置为 91（与 MIMIC 规则一致的近似）
       .with_columns(pl.when(pl.col("age_at_icu")>=90).then(91).otherwise(pl.col("age_at_icu")).alias("age_capped"))
       .with_columns([
           (pl.col("gender")=="M").cast(pl.Int8).alias("sex_m"),
           (pl.col("gender")=="F").cast(pl.Int8).alias("sex_f")
       ])
       .select(["stay_id","subject_id","age_capped","sex_m","sex_f","first_careunit"])
       .rename({"age_capped":"age"})
)
```

> 建议：可同时保留**年龄分箱**特征（如 `age_bin_10yr`），并记录高龄标记 `is_elderly = age>=65`。

---

## 8.2 就诊信息：入出院、ICU 停留、转运

**遵循“仅用 24h 前可获信息”**：

* 可用：`admittime`、`intime`、`first_careunit`、入院来源/类型、**ICU 入科的时段特征**（夜间/周末）等。
* **不可用**：`dischtime`/`outtime`/`deathtime` 本身作为特征（属于未来信息）。若用于**筛选**（如确保可观察 48h），需在建模表中**剔除这些列**。

**推荐就诊特征（示例）**

* **入院到 ICU 间隔**（小时）：`time_admit_to_icu_h = intime - admittime`
* **入科时段**：`icu_hour = hour(intime)`、`icu_is_night = icu_hour in [22..6]`、`icu_is_weekend`
* **来源/类型**：`admission_type`（EMERGENCY/ELECTIVE/URGENT…）、`admission_location`（ED/转院/门诊…）
* **ICU 单位**：`first_careunit` one-hot
* **转运特征（0–24h 内）**：

  * **入 ICU 前病区转运次数**：`n_transfers_pre_icu`（`transfers.outtime <= intime`）
  * **ICU 内 0–24h 转床次数**：`n_transfers_icu_0_24h`（`transfers` 与 ICU 时窗相交，且 `< 24h`）

**实现（Polars）**

```python
ADM = RAW/"mimiciv_hosp/admissions.csv.gz"
TRN = RAW/"mimiciv_hosp/transfers.csv.gz"

adm = (
    pl.scan_csv(ADM)
      .select(["subject_id","hadm_id","admittime","admission_type","admission_location"])
      .collect()
)

# 基础 join：ICU + Admissions
enc = (
    icu.join(adm, on=["subject_id","hadm_id"], how="left")
       .with_columns([
          ((pl.col("intime") - pl.col("admittime")).dt.seconds() / 3600.0).alias("time_admit_to_icu_h"),
          pl.col("intime").dt.hour().alias("icu_hour"),
          pl.col("intime").dt.weekday().alias("icu_weekday")   # Monday=0
       ])
       .with_columns([
          ((pl.col("icu_hour")>=22) | (pl.col("icu_hour")<=6)).alias("icu_is_night").cast(pl.Int8),
          (pl.col("icu_weekday")>=5).alias("icu_is_weekend").cast(pl.Int8)
       ])
       # one-hot（简化：两三个主要类别；更多类别可在后续特征化时处理）
       .with_columns([
          (pl.col("admission_type").str.contains("EMERGENCY", literal=True)).cast(pl.Int8).alias("admtype_emerg"),
          (pl.col("admission_type").str.contains("ELECTIVE", literal=True)).cast(pl.Int8).alias("admtype_elect"),
       ])
       .select(["stay_id","hadm_id","time_admit_to_icu_h","icu_is_night","icu_is_weekend",
                "admtype_emerg","admtype_elect","first_careunit"])
)

# 转运特征
trn = (
    pl.scan_csv(TRN)
      .select(["hadm_id","careunit","intime","outtime"])
      .collect()
)

# 入 ICU 前转运次数
pre_icu = (
    trn.join(icu.select(["hadm_id","stay_id","intime"]), on="hadm_id", how="inner")
       .filter(pl.col("outtime") <= pl.col("intime"))
       .groupby("stay_id").count().rename({"count":"n_transfers_pre_icu"})
)

# ICU 内 0–24h 转床（careunit 变化视作一次转运；这里按 transfers 的记录计数）
icu_0_24 = (
    trn.join(icu.select(["hadm_id","stay_id","intime"]), on="hadm_id", how="inner")
       .filter(
          (pl.col("outtime") > pl.col("intime")) &
          (pl.col("intime") < pl.col("intime") + pl.duration(hours=24))  # 有交集
       )
       .groupby("stay_id").count().rename({"count":"n_transfers_icu_0_24h"})
)

enc_feats = (
    enc.join(pre_icu, on="stay_id", how="left")
       .join(icu_0_24, on="stay_id", how="left")
       .with_columns([
          pl.col("n_transfers_pre_icu").fill_null(0),
          pl.col("n_transfers_icu_0_24h").fill_null(0)
       ])
)
```

> 提示：`first_careunit` 建议做 one-hot（MICU/SICU/CCU/CSRU/TSICU 等），但在树模型中保留原始分类列也可行（需 LabelEncoder）；确保**训练/验证/测试**的类别一致（未见类别要兜底）。

---

## 8.3 合并症：Charlson/Elixhauser（优先读取 derived；否则从 ICD 派生）

**合并症在早期风险预测中非常重要**，但**来源与时间性**要说明：

* **优先**使用 `mimic-iv-derived` 中的 **Charlson/Elixhauser**（若可获得 CSV/Parquet）：通常已按公开规则把 ICD9/10 归并为合并症构成与得分。
* 如无 derived：从 `diagnoses_icd` + `d_icd_diagnoses` 映射得到合并症**标志**与**总分**。
* **时间性/潜在泄漏**：MIMIC 的 `diagnoses_icd` 是**整次住院**的诊断列表，可能包含**入院后并发症**。临床常将 Charlson/Elixhauser 视作“既往合并症”代理，但**严格零泄漏**时，建议：

  * 做**敏感性分析**：比较“含住院内诊断 vs 去除明显并发症代码”的影响；
  * 或在队列上使用“既往住院（历史）”诊断（实现较复杂，可作为扩展工作）。

### 8.3.1 路线 A：直接读取 derived 的 Charlson/Elixhauser

```python
DERIVED_ROOT = RAW/"mimiciv_derived"
charlson_p = DERIVED_ROOT/"charlson.csv.gz"        # 可能命名不同，先用 head() 探查
elix_p     = DERIVED_ROOT/"elixhauser_quan.csv.gz" # 例如 Quan 映射版

char = (pl.scan_csv(charlson_p).collect()           # 典型列：hadm_id/subject_id/charlson_score + 组件标志
          .select(["hadm_id","charlson_score"])).unique(subset=["hadm_id"])
eli  = (pl.scan_csv(elix_p).collect()               # 典型列：hadm_id + 各系统性合并症 0/1
          .select(["hadm_id"]))  # 或保留全部组件列

# 合并到 stay（通过 hadm_id）
comorb = (
    icu.select(["stay_id","hadm_id"])
       .join(char, on="hadm_id", how="left")
       .join(eli,  on="hadm_id", how="left")
       .fill_null(0)
)
```

### 8.3.2 路线 B：从 ICD 派生（教学实现轮廓）

**思路**：加载一份**ICD→合并症类别**的映射（Quan 等公开映射），对 `diagnoses_icd` 聚合为组件 0/1，再按规则求和/加权得到得分。

> 实操：把映射维护成 `configs/charlson_icd_map.csv` 与 `configs/elixhauser_icd_map.csv`，字段至少含：`icd_version, icd_code_prefix, comorb_name, weight`。

```python
DIAG  = RAW/"mimiciv_hosp/diagnoses_icd.csv.gz"
# 1) 诊断明细（住院级）
dx = (
    pl.scan_csv(DIAG)
      .select(["subject_id","hadm_id","icd_code","icd_version"])
      .collect()
      .with_columns([
          pl.col("icd_code").str.to_uppercase().alias("code"),
          pl.col("icd_version").cast(pl.Int8)
      ])
)

# 2) 读取 ICD→Charlson 映射（你将维护在项目仓库的 configs/ 中）
map_char = pl.read_csv("src/configs/charlson_icd_map.csv")  
# 期望列：["icd_version","prefix","comorb","weight"]
map_char = map_char.with_columns([pl.col("prefix").str.to_uppercase()])

# 3) 前缀匹配（为避免 O(N*M)，先按版本拆分并限制前缀长度；也可将映射加载为 trie/正则）
def tag_comorb(dx: pl.DataFrame, mp: pl.DataFrame) -> pl.DataFrame:
    # 简单实现：对每个 comorb 的 prefix 列表做多条件匹配（小样本可行；大样本建议预编译正则）
    parts = []
    for row in mp.iter_rows(named=True):
        ver, pref, com, w = row["icd_version"], row["prefix"], row["comorb"], row["weight"]
        sub = dx.filter(pl.col("icd_version")==ver).filter(pl.col("code").str.starts_with(pref))
        if sub.height > 0:
            parts.append(sub.select(["hadm_id"]).unique().with_columns([
                pl.lit(1).alias(com),
                pl.lit(int(w)).alias(f"{com}_w")
            ]))
    return pl.concat(parts) if parts else pl.DataFrame([])

char_flags = tag_comorb(dx, map_char)

# 4) 同一 hadm_id 上按组件聚合为 0/1 与权重和
if char_flags.height > 0:
    # 将 wide 合并到 hadm 粒度
    char_wide = char_flags.groupby("hadm_id").agg([
        # 对每个组件列取 max（是否出现）
        *[pl.max(c).alias(c) for c in set(char_flags.columns) if c not in ("hadm_id",) and not c.endswith("_w")],
        pl.sum(pl.all().suffix("_w")).alias("charlson_score")  # 简化：把权重累加
    ])
else:
    char_wide = pl.DataFrame({"hadm_id":[],"charlson_score":[]})
```

> 说明：上面是**教学实现轮廓**。实际项目建议：
>
> * 预先把映射做成多行 → 多个正则表达式（每个合并症 1 个正则），一次性 `str.contains`；
> * 或使用 Polars 的 `when/then` 批量向量化匹配；
> * 映射文件需与论文/来源一致并标注版本；
> * Elixhauser 同理；**Charlson/Elixhauser 不要混加**（分别作为两套特征或只选其一）。

---

## 8.4 合并与落盘（本章产物）

将 **人口学 (`demo`) + 就诊 (`enc_feats`) + 合并症（`comorb`）** 合并成**基础特征表**，键为 `stay_id`（建模粒度），并**只保留 24h 前可得信息**。

```python
# 合并（注意：comorb 是 hadm 级 → join 到 stay）
basic = (
    demo.select(["stay_id","subject_id","age","sex_m","sex_f","first_careunit"])
        .join(enc_feats.select(["stay_id","time_admit_to_icu_h","icu_is_night","icu_is_weekend",
                                "admtype_emerg","admtype_elect"]),
              on="stay_id", how="left")
        .join(comorb.select(["hadm_id","charlson_score"]),  # 也可加上各组件 0/1
              on="hadm_id", how="left")
        .with_columns(pl.col("charlson_score").fill_null(0))
        .select(["stay_id","subject_id","age","sex_m","sex_f","first_careunit",
                 "time_admit_to_icu_h","icu_is_night","icu_is_weekend",
                 "admtype_emerg","admtype_elect","charlson_score"])
)

basic.write_parquet(DER/"features_basic_0_24h.parquet")
```

---

## 8.5 质量控制与防泄漏自检

* [ ] **人口学**：`age` 按年近似（`anchor_age + year(intime) - anchor_year`），≥90 记为 91；性别 one-hot。
* [ ] **就诊**：不把 `outtime/dischtime/deathtime` 作为特征；`time_admit_to_icu_h` 非负；夜间/周末按 `intime` 计算。
* [ ] **转运**：`n_transfers_pre_icu` 仅统计 `outtime <= intime`；`n_transfers_icu_0_24h` 与 `[0,24h)` 相交。
* [ ] **合并症**：优先用 derived；若 ICD 派生，映射版本与规则固定，输出**组件 0/1 + 总分**，并在方法中说明可能的时间性偏倚。
* [ ] **落盘**：仅保留 24h 前可得信息；输出到 `derived/features_basic_0_24h.parquet`，后续与实验室/生命体征等在 `stay_id` 上合并。

---

### 下一步建议

* 将本章产出的 `features_basic_0_24h.parquet` 与第 4–5 章的 **实验室 0–24h 聚合**、第 9 章的 **生命体征 0–24h 聚合**拼接，形成 `features_all_0_24h.parquet`。
* 进入 **第 9 章：关键医学特征（化验/生命体征/尿量/用药）**，我们将给出**稳健聚合**与**单位统一**的模板，并对缺失机制与插补策略进行约定。

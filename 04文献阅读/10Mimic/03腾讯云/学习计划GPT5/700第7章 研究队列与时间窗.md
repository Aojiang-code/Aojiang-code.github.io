下面是**第7章：研究队列与时间窗**的详细学习笔记。
全章坚持你的技术约束：**DuckDB + CSV/Parquet + Python（pandas/Polars）+ Jupyter（VSCode）**，**不使用 SQL / Postgres**。示例均为**数据帧工作流**范式，可直接嵌入 Notebook。

---

# 第7章 研究队列与时间窗

## 7.1 目标：预测 ICU 入科后 24–48 小时是否发生 AKI（≥Stage 1）

**任务定义（binary/class + optional ordinal）：**

* **特征窗（Features Window）**：ICU 入科起算 **0–24h** 内的可用数据（化验/生命体征/用药/合并症等的聚合或衍生）。
* **标签窗（Label Window）**：**24–48h** 内是否满足 **KDIGO ≥ Stage 1**。
* **输出**：

  * 二分类：`aki_label` ∈ {0,1}；
  * 可选序列：`aki_stage` ∈ {0,1,2,3}（用于次级分析）。
* **实时性原则**：**仅使用在 24h 时点之前“可获得”的信息**作为特征；任何超过 24h 的信息都不得进入特征。

---

## 7.2 样本选择：首次 ICU 停留 / 按科室 / 按诊断过滤（可选）

> 目标：构建一个**清晰、可观察**且**无重复泄漏**的 cohort。

### 7.2.1 基础 cohort（首次 ICU 停留）

* **去重策略**：每位患者仅保留**首次 ICU 停留**（避免同一患者多次入 ICU 的“个体信息泄漏”）。
* **观察充分**：要求能完整观察 **\[0,48h)**（至少用于判定标签窗），常见做法：`outtime - intime ≥ 48h`；否则将该 stay 标记为“不可判定”并**剔除**监督训练。
* **成人筛选（可选）**：若研究仅限成人，剔除年龄 < 18 的患者（年龄计算逻辑见第4–5章）。

### 7.2.2 场景过滤（可选）

* **按科室**：例如只选 `first_careunit` ∈ {MICU, SICU, CCU…} 的样本，提高队列同质性或做分层。
* **按诊断/合并症**：基于 `diagnoses_icd` 过滤（如剔除 ESRD、移植患者；或只研究败血症亚组）。
* **按数据可用性**：保底特征覆盖（如 0–24h 至少有 1 次 SCr 或 3 类生命体征）。

**示例（Polars）**：

```python
from pathlib import Path
import polars as pl

RAW = Path("data/raw")
DER = Path("data/derived"); DER.mkdir(parents=True, exist_ok=True)

ICU = RAW/"mimiciv_icu/icustays.csv.gz"
ADM = RAW/"mimiciv_hosp/admissions.csv.gz"
PAT = RAW/"mimiciv_hosp/patients.csv.gz"

icu = (pl.scan_csv(ICU)
         .select(["subject_id","hadm_id","stay_id","intime","outtime","first_careunit"])
         .collect())

# 首次 ICU 停留（按 subject_id 最早 intime）
icu_first = (
    icu.sort("intime")
       .groupby("subject_id", maintain_order=True)
       .agg([pl.all().first()])
       .explode(pl.all().exclude("subject_id"))
       .select(["subject_id","hadm_id","stay_id","intime","outtime","first_careunit"])
)

# 观察充分：至少 48h
icu_first = icu_first.with_columns(
    ((pl.col("outtime") - pl.col("intime")).dt.seconds() / 3600.0).alias("icu_hours")
).filter(pl.col("icu_hours") >= 48)

# （可选）按科室过滤
keep_units = ["Medical Intensive Care Unit (MICU)", "Surgical Intensive Care Unit (SICU)"]
cohort = icu_first.filter(pl.col("first_careunit").is_in(keep_units))
```

---

## 7.3 窗口设计：特征窗（0–24h）与标签窗（24–48h）的**严格隔离**

> 原则：**窗口物理隔离** + **特征生成函数只看 0–24h** + **标签生成函数只看 24–48h**。
> 任何\*\*跨窗信息、未来信息（如出院时间、48h 后的 lab 值）\*\*都不得混入特征。

### 7.3.1 与第6章的衔接

* **标签**：使用第6章产物：

  * 路线 A：`derived/label_kdigo_24_48h.parquet`
  * 路线 B：`derived/label_scronly_24_48h.parquet`
* **特征**：第4–5章已经给出“化验 0–24h 聚合”的模板（例如 `interim/features_labs_0_24h.parquet`）。生命体征/尿量的 0–24h 聚合可用相同模式生成。

### 7.3.2 合并 cohort + 特征 + 标签

```python
# 读取标签（任选其一；优先使用 derived 版）
lbl = pl.read_parquet(DER/"label_kdigo_24_48h.parquet") \
      if (DER/"label_kdigo_24_48h.parquet").exists() \
      else pl.read_parquet(DER/"label_scronly_24_48h.parquet") \
            .rename({"aki_label_scr":"aki_label","aki_stage_scr":"aki_stage"})

# 读取 0–24h 特征（以化验为例；你还可以并入 vitals/尿量/用药等 0–24h 聚合）
FEA = Path("data/interim")/"features_labs_0_24h.parquet"
X_labs = pl.read_parquet(FEA)  # 列格式示例：stay_id + lab_xxx_mean/min/max/last ...

# 合并到 cohort（先与标签对齐，避免把无标签样本混入）
base = (cohort.join(lbl.select(["stay_id","aki_label","aki_stage"]), on="stay_id", how="inner")
              .join(X_labs, on="stay_id", how="left"))

# 可选：剔除 0–24h 内完全无特征的样本（缺特征的极端情况）
base = base.drop_nulls(subset=["aki_label"])  # 确保标签存在
```

### 7.3.3 防泄漏检查清单（在特征工程阶段强制执行）

* [ ] 特征仅来源于 `charttime ∈ [intime, intime+24h)`（或 admission 前既往固定信息如性别/史）。
* [ ] **不使用** `outtime/dischtime/deathtime` 等**未来**变量作为特征（允许用于样本筛选，但不能入模）。
* [ ] 不使用来自标签窗 `[24h, 48h)` 的任何原始或聚合信息。
* [ ] 若使用“最近值 last”，需确保 last 的时间戳 < 24h 截止。
* [ ] 若存在“窗口跨越边界”的滚动统计，**截断**到 24h 内。
* [ ] 若做归一化（如尿量 mL/kg/h），使用 24h 前可得的体重。

---

## 7.4 训练/验证/测试切分：按时间、按患者分组、避免数据泄漏

> **首选**：**按患者分组（Group）**的分层切分，保证同一患者**仅出现在一个集合**，杜绝个体间信息泄漏。
> 时间切分在 MIMIC 有局限（因跨患者的时间被偏移），可作为**次选**或**锚年组近似**。

### 7.4.1 首选：分层+分组（StratifiedGroupKFold）

* **分组键**：`subject_id`（保证患者不跨集合）。
* **分层标签**：`aki_label`（保持阳性率稳定）。
* **典型配置**：`train/valid/test = 60/20/20` 或 K 折交叉验证（如 5 折）。
* **实现**：`sklearn.model_selection.StratifiedGroupKFold`（scikit-learn 1.4+）。

```python
import numpy as np
import pandas as pd
from sklearn.model_selection import StratifiedGroupKFold

# 准备建模 DataFrame（pandas 便于与 sklearn 对接）
pdf = base.to_pandas()
y = pdf["aki_label"].astype(int).values
groups = pdf["subject_id"].values

# 例：5 折 StratifiedGroupKFold（或自定义 60/20/20）
cv = StratifiedGroupKFold(n_splits=5, shuffle=True, random_state=42)
folds = []
for k, (tr, te) in enumerate(cv.split(np.zeros(len(y)), y, groups)):
    folds.append({"fold": k, "train_idx": tr, "test_idx": te})
len(folds), [len(f["test_idx"]) for f in folds]
```

> 可将其中一折作为**最终测试集**（外部验证），其余用于训练/调参（内层交叉）。

### 7.4.2 近似“时间切分”（谨慎使用）

由于 MIMIC 的日期**跨患者不可比**，全局时间切分并非真实时间外推。可选近似：

* **按 `anchor_year_group`**：选择早期组做训练、晚期组做测试（跨组仍存在偏移风险）。
* **按 ICU 入科序位**：在每个 `first_careunit` 内按 `intime` 排序，前 70% 作训练、后 30% 作测试（只是一种结构化划分）。
* **按“月份桶/锚年桶”**：在患者内部排名或用粗粒度时间桶做分割。

**示例（按科室内 intime 排序切分，作为结构化 holdout）**

```python
# 在每个 careunit 内，按 intime 排序，后 20% 作为 holdout（伪时间切分）
def unit_temporal_holdout(df: pl.DataFrame, holdout_ratio=0.2):
    parts = []
    for u in df["first_careunit"].unique().to_list():
        d = df.filter(pl.col("first_careunit")==u).sort("intime")
        n = d.height
        k = int(n * (1 - holdout_ratio))
        d = d.with_columns(
            pl.arange(0, n).alias("_rank")
        ).with_columns(
            (pl.col("_rank") >= k).alias("is_holdout")
        ).drop("_rank")
        parts.append(d)
    return pl.concat(parts)

split_mark = unit_temporal_holdout(base, holdout_ratio=0.2)
train_df = split_mark.filter(~pl.col("is_holdout"))
test_df  = split_mark.filter(pl.col("is_holdout"))
```

### 7.4.3 领域泛化评估（可选）

* **Careunit 外推**：训练集与验证集使用部分 ICU 单位，测试集用**未见**的 ICU 单位（如留出 CCU 作为外部域）。
* **医院流程差异近似**：按周末/夜间入科、急诊来源等切分，检查模型稳健性。
* **样本采样偏倚控制**：对训练集做 `class_weight="balanced"` 或分层欠/过采样（但保持验证/测试的自然分布）。

### 7.4.4 切分与特征生成顺序（强制）

1. **确定 cohort**（含观测充分的 stay\_id 列表）。
2. **生成标签**（第6章，严格用 24–48h）。
3. **生成 0–24h 特征**（第4–5章）。
4. **合并**并**固定索引**（`stay_id`）。
5. **再做切分**（基于 `subject_id` 分组/分层）。

> 任何在切分之后才生成的特征，都必须仅使用训练集信息（例如**标准化器/缺失插补器**仅在训练集拟合，然后应用到验证/测试），以避免**数据泄漏**。

---

## 产出与检查清单（本章落地结果）

**数据产出（Parquet / CSV）**

* `derived/cohort_base.parquet`：`subject_id, hadm_id, stay_id, intime, outtime, first_careunit, icu_hours`
* `derived/label_24_48h.parquet`：`stay_id, aki_label, aki_stage`（来自第6章 A 或 B）
* `interim/features_0_24h_*.parquet`：化验/生命体征/尿量/用药等 0–24h 聚合
* `derived/model_table.parquet`：合并后的建模表（仅 24h 前特征 + 标签）

**切分产出**

* `derived/splits_stratified_group.json`：记录每个集合的 `stay_id`/`subject_id` 列表与阳性率
* （可选）`derived/split_holdout_by_unit.parquet`：结构化 holdout 标记

**自检清单**

* [ ] **首次 ICU** 去重正确，且 **outtime - intime ≥ 48h**
* [ ] 标签仅来自 `[24h,48h)`；特征仅来自 `[0h,24h)`
* [ ] 训练/验证/测试**按患者分组**；同一 `subject_id` 未跨集合
* [ ] 特征流水线中无未来信息（`outtime` 只用于筛选，不入模）
* [ ] 切分元数据（阳性率、样本数、单位分布）已记录，便于复现实验

---

若你认可第7章的笔记，我可以马上给出一个**可直接运行的 Notebook 骨架**：

* `07_build_cohort.ipynb`（首次 ICU + 观察充分 + 可选过滤）；
* `07_merge_features_labels.ipynb`（合并 0–24h 特征与 24–48h 标签）；
* `07_make_splits.ipynb`（StratifiedGroupKFold + 结构化 holdout）。
  接下来我们就能进入 **第8–10章 特征工程** 与 **第11–13章 建模/评估/解释**。
